/*
 * ArcEmu MMORPG Server
 * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
 * Copyright (C) 2008 <http://www.ArcEmu.org/>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __SPELL_H
#define __SPELL_H

#include "SpellFailure.h"
#include "StdAfx.h"

class WorldSession;
class Unit;
class DynamicObj;
class Player;
class Item;
class Group;
class Aura;
class Corpse;
/*
Spell Description macros
$s1 - value is calculated from spellcaleID
$m1 - value is calculated from effectbasepoints and levelbasedpoints
$b - base damage without the randompoints added to it
$ap - probably rage amount we currently have capped by some value ( execute is using max 570 rage)
*/

/* Spell Ranges:(for 1.10.2)
Range ID|Range|Description
1       0-0     Self Only
2       0-5     Combat Range
3       0-20    Short Range
4       0-30    Medium Range
5       0-40    Long Range
6       0-100   Vision Range
7       0-10    Very Short Range
8       10-20   Short Range
9       10-30   Medium Range
10      10-40   Long Range
11      0-15    Shorter Range
12      0-5     Interact Range
13      0-50000 Anywhere
14      0-60    Extra Long Range
34      0-25    Medium-Short Range
35      0-35    Medium-Long Range
36      0-45    Longer Range
37      0-50    Extended Range
38      10-25   Extra Medium Range
54      5-30    Geoff Monster Shoot
74      8-30    Ranged Weapon
94      8-40    Sting
95      8-25    Charge
96      0-2     Trap
114     8-35    Hunter Range Hunter
134     0-80    Tower 80 Tower
135     0-100   Tower 100 Tower
*/

/*FLAT PCT
0    x    x
1    x    x
2    x    x
3         x
4    x
5    x    x
6    x    x
7    x =  x//both add % to crit
8    x    x
9         x
10   x    x
11   x    x
12   x
13    
14   x    x
15        x
16   x    
17   x
18   x    x
19   x
20        x
21    
22   x    x
23   x(enslave dem)
24    
25
26   x(obsolete)
27        x
*/

//wooohooo, there are 19 spells that actually require to add a proccounter for these 
//first spell catched is "presence of mind"
//an ugly solution would be to add a proc flag to remove aura on event it should expire (like attack or cast) but that is only if count=1
enum SPELL_MODIFIER_TYPE
{
    SMT_DAMAGE_DONE         =0,//302 -> spell power -> both dmg and heal // increases the damage done by spell by x% dmg (flat as x dmg)
    SMT_DURATION            =1,// spell    duration increase // GOOD
    //hmm shaman spirit weapon clearly states that this should be parry chance
    SMT_THREAT_REDUCED      =2,// reduces threat generated by this spell by x% // GOOD but need more work
    SMT_ATTACK_POWER_AND_DMG_BONUS=3,//302 -> armor,dmg,distance,effectiveness,AP,melee haste,speed,absorb,speed
    SMT_CHARGES             =4,// block additional attack // GOOD and need work //Not used in 2.1.1 ?
    SMT_RANGE               =5,// spell range bonus // GOOD
    SMT_RADIUS              =6,// spell radius bonus // GOOD
    SMT_CRITICAL            =7,// critical chance bonus // GOOD //only 1 example in 2.1.1
    SMT_MISC_EFFECT         =8,//302_.effect,damage,chance,heal,AP,regen, // dummy effect // needs work is not only pets Hp but effect of spells to
    SMT_NONINTERRUPT        =9,// x% chance not to be interrupted by received damage (no flat)
    SMT_CAST_TIME           =10,// cast time decrease // GOOD
    SMT_COOLDOWN_DECREASE   =11,// cooldown decrease <-probably fully handled by client // GOOD
    SMT_EFFECT_TARGET       = 12,//302 effect on target //used by shaman elemental weapons and another spell
    // 13 dont exist spells with it
    SMT_COST                =14,// mana/energy/rage cost reduction // GOOD
    SMT_CRITICAL_DAMAGE     =15,// increases critical strike damage bonus (no flat)
    SMT_HITCHANCE           =16,// enemy resist chance decrease (flat as %) // GOOD need work
    SMT_ADDITIONAL_TARGET   =17,// Your Healing Wave will now jump to additional nearby targets. Each jump reduces the effectiveness of the heal by 80% // GOOD
    SMT_TRIGGER             =18,// adds/increases chance to trigger some spell for example increase chance to apply poisons or entaglin // GOOD need work
    SMT_TIME                =19,// delay for nova, redirection time bonus for totem,maybe smth else // GOOD need work
    SMT_JUMP_REDUCE         =20,// Increases the amount healed by Chain Heal to targets beyond the first by x%. (no flat)
    SMT_GLOBAL_COOLDOWN      =21,// 302->reduces global cooldown
	//!!! most spells have both SMT_DAMAGE_DONE and this value. Be carefull case there is no need to apply both !
    SMT_SPELL_VALUE_DOT		=22,//302->periodic dmg // damage done by ability by x% : SELECT id,name,description FROM dbc_spell where (EffectApplyAuraName_1=108 and EffectMiscValue_1=22) or (EffectApplyAuraName_2=108 and EffectMiscValue_2=22) or (EffectApplyAuraName_3=108 and EffectMiscValue_3=22)  its DoT actually
    SMT_SPELL_CRIT_CHANCE_IF=23,//302->conditional critical chance increase // this seems to be some scripted effect. From 8 spells not even 1 has description what it does
    SMT_PENALTY             =24,// This is a modifer for the amount of +spell damage applied to the spell group from spell bonuses
    // 25 dont exist spells with it
    // 26 is obsolete stuff
    SMT_EFFECT_BONUS        =27,// mana lost cost per point of damage taken for mana shield,Health or Mana gained from Drain Life and Drain Mana increased by x%.
    SMT_RESIST_DISPEL       =28,// TODO NEEDS WORK :D

	//custom ones !!!
    SMT_ADD_TO_EFFECT_VALUE_1      =40,//only added when spell value 1 is calculated
    SMT_ADD_TO_EFFECT_VALUE_2      =41,//only added when spell value 2 is calculated
    SMT_ADD_TO_EFFECT_VALUE_3      =42,//only added when spell value 3 is calculated
    SMT_AVOID_MOVE_INTERRUPT       =43,//if spell has this mod then it will ignore the move interrupt
    SMT_ADD_TO_EFFECT_VALUE_DUMMY  =44,//started remaking SMTs into class overrides because they randomly bug out other spells. I use this type to only mod client interface and not server side also
};

//note that there are some flags that can send combined data 
enum CombatLogType
{
    COMBAT_LOG_SPELL_DAMAGE		         = 0xB2AE,
    COMBAT_LOG_ENERGIZE                  = 0x7A2A,
    COMBAT_LOG_HEAL                      = 0xF673,
    COMBAT_LOG_PERIODIC_HEAL             = 0xA2A3,
    COMBAT_LOG_PERIODIC_ENERGIZE	     = 0xA2A3,	//need to implement flags for this
    COMBAT_LOG_PERIODIC_DAMAGE		     = 0xA2A3,	//need to implement flags for this
    COMBAT_LOG_EXECUTE                   = 0x2476,	//not updated
    COMBAT_LOG_MISS                      = 0x855E,	//not updated
    COMBAT_LOG_REMOVE_1                  = 0xED7E,       // currently unused
    COMBAT_LOG_REMOVE_2                  = 0x9F74,       // currently unused
    COMBAT_LOG_REMOVE_3                  = 0xD557,       // currently unused
    COMBAT_LOG_ENERGiZE_AND_HEAL         = 0xF557,       // currently unused

	COMBAT_LOG_SUBFLAG_PERIODIC_HEAL	 = 0x08,
	COMBAT_LOG_SUBFLAG_PERIODIC_ENERGIZE = 0x18,
	COMBAT_LOG_SUBFLAG_PERIODIC_DAMAGE	 = 0x03,
};

#define SPELL_RADIUS_INDEX_2YARDS	7	//for melee stuff

#define SPELL_POWER_TO_HEALING_POWER_CONVERSION_FACTOR	1		//some say that arcemu heals are imba. Maybe reduce this ?

#define DEFAULT_SPELL_PROC_INTERVAL			500		//avoid proc exploits ( some people managed to proc over proc spells creating insane DPS, this protection is only for future bug avoiding)
#define DEFAULT_SPELL_ITEM_PROC_INTERVAL	10000		//avoid proc exploits ( some people managed to proc over proc spells creating insane DPS, this protection is only for future bug avoiding)

#define MAX_SPELL_TARGET_COUNT		60			//someone managed to find some spell that has "infinit" range and AOE

enum SpellReflectState
{
	SPELL_REFLECT_NONE				= 0,
	SPELL_REFLECT_ORIGINAL_CANCEL	= 1,
	SPELL_REFLECT_ALREADY_REFLECTED	= 2,
};

static void SM_FFValue( int32* ObjectSMVal, float* DestValue, uint32 *SpellGroupMask )
{
	if( !ObjectSMVal || !DestValue || !SpellGroupMask )
		return;
	ASSERT( DestValue );
	ASSERT( SpellGroupMask );

    for( uint32 x = 0; x < 32; x++ )
	{
		uint32 tmask = 1 << x;
        if( tmask & SpellGroupMask[0] )
            DestValue[0] += ObjectSMVal[x];
        if( tmask & SpellGroupMask[1] )
            DestValue[0] += ObjectSMVal[x+32];
        if( tmask & SpellGroupMask[2] )
            DestValue[0] += ObjectSMVal[x+64];
	}
}

static void SM_FIValue( int32* ObjectSMVal, int32* DestValue, uint32 *SpellGroupMask )
{
	if( !ObjectSMVal || !DestValue || !SpellGroupMask )
		return;
	ASSERT( DestValue );
	ASSERT( SpellGroupMask );

    for( uint32 x = 0; x < 32; x++ )
	{
		uint32 tmask = 1 << x;
        if( tmask & SpellGroupMask[0] )
            DestValue[0] += ObjectSMVal[x];
        if( tmask & SpellGroupMask[1] )
            DestValue[0] += ObjectSMVal[x+32];
        if( tmask & SpellGroupMask[2] )
            DestValue[0] += ObjectSMVal[x+64];
	}
}

static void SM_PIValue( int32* ObjectSMVal, int32* DestValue, uint32 *SpellGroupMask )
{
	if( !ObjectSMVal || !DestValue || !SpellGroupMask )
		return;
	ASSERT( DestValue );
	ASSERT( SpellGroupMask );

    for( uint32 x = 0; x < 32; x++ )
	{
		uint32 tmask = 1 << x;
        if( tmask & SpellGroupMask[0] )
            DestValue[0] += ( DestValue[0] * ObjectSMVal[x] ) / 100;
        if( tmask & SpellGroupMask[1] )
            DestValue[0] += ( DestValue[0] * ObjectSMVal[x+32] ) / 100;
        if( tmask & SpellGroupMask[2] )
            DestValue[0] += ( DestValue[0] * ObjectSMVal[x+64] ) / 100;
	}
}

static void SM_PFValue( int32* ObjectSMVal, float* DestValue, uint32 *SpellGroupMask )
{
	if( !ObjectSMVal || !DestValue || !SpellGroupMask  )
		return;
	ASSERT( DestValue );
	ASSERT( SpellGroupMask );
    
    for( uint32 x = 0; x < 32; x++ )
	{
		uint32 tmask = 1 << x;
        if( tmask & SpellGroupMask[0] )
            DestValue[0] += ( DestValue[0] * ObjectSMVal[x] ) / 100.0f;
        if( tmask & SpellGroupMask[1] )
            DestValue[0] += ( DestValue[0] * ObjectSMVal[x+32] ) / 100.0f;
        if( tmask & SpellGroupMask[2] )
            DestValue[0] += ( DestValue[0] * ObjectSMVal[x+64] ) / 100.0f;
	}
}

enum SPELL_INFRONT_STATUS
{
	SPELL_INFRONT_STATUS_REQUIRE_INFRONT	= 1,
	SPELL_INFRONT_STATUS_REQUIRE_INBACK		= 2,
	SPELL_INFRONT_STATUS_REQUIRE_SKIPCHECK	= 3,
};

//bool IsBeneficSpell(SpellEntry *sp);
//AI_SpellTargetType RecommandAISpellTargetType(SpellEntry *sp);

enum SPELL_DMG_TYPE // SPELL_ENTRY_Spell_Dmg_Type
{
	SPELL_DMG_TYPE_NONE   = 0,
	SPELL_DMG_TYPE_MAGIC  = 1,
	SPELL_DMG_TYPE_MELEE  = 2,
	SPELL_DMG_TYPE_RANGED = 3,
	SPELL_DMG_TYPE_COUNT
};

enum SPELL_RUNE_TYPES
{
	RUNE_BLOOD			= 0,
	RUNE_UNHOLY			= 1,	//this is 3rd slot client side
	RUNE_FROST			= 2,
	RUNE_DEATH			= 3,
	RUNE_TYPE_COUNT		= 4,	//counter for notmar rune types
	RUNE_NOTIMPLEMENTED	= 20,//just some value that will make client think we do not have that type of rune
};

#define MAX_RUNE_VALUE 0xFF 

// value's for SendSpellLog
enum SPELL_LOG
{
    SPELL_LOG_NONE,
    SPELL_LOG_MISS,
    SPELL_LOG_RESIST,
    SPELL_LOG_DODGE,
    SPELL_LOG_PARRY,
    SPELL_LOG_BLOCK,
    SPELL_LOG_EVADE,
    SPELL_LOG_IMMUNE,
    SPELL_LOG_IMMUNE2,
    SPELL_LOG_DEFLECT,
    SPELL_LOG_ABSORB,
    SPELL_LOG_REFLECT
};

enum VisualAuraSendFlags
{
	VISUALAURA_FLAG_VISIBLE_1		= 0x01, //could not find 1 example that was missing this flag
	VISUALAURA_FLAG_VISIBLE_2		= 0x02, //could not find 1 example that was missing this flag
	VISUALAURA_FLAG_VISIBLE_3		= 0x04, //could not find 1 example that was missing this flag
	VISUALAURA_FLAG_SELF_CAST		= 0x08, //self cast does not require guid
	VISUALAURA_FLAG_REMOVABLE		= 0x10, //can remove it client side
	VISUALAURA_FLAG_HAS_DURATION	= 0x20, //send duration and duration left
	VISUALAURA_FLAG_SEND_VALUES		= 0x40, //after duration send int32 (max 3 based on flags visible 1,2,3)
	VISUALAURA_FLAG_NEGATIVE		= 0x80, //red icon client side
};

enum SpellCastTargetFlags
{
    TARGET_FLAG_SELF                = 0x0000, // they are checked in following order
    TARGET_FLAG_UNK1                = 0x0001,
    TARGET_FLAG_UNIT                = 0x0002,
    TARGET_FLAG_UNK2                = 0x0004,
    TARGET_FLAG_UNK3                = 0x0008,
    TARGET_FLAG_ITEM                = 0x0010,
    TARGET_FLAG_SOURCE_LOCATION     = 0x0020,
    TARGET_FLAG_DEST_LOCATION       = 0x0040,
    TARGET_FLAG_UNK6                = 0x0080,
    TARGET_FLAG_UNK7                = 0x0100,
    TARGET_FLAG_CORPSE              = 0x0200,
    TARGET_FLAG_UNK8                = 0x0400,
    TARGET_FLAG_OBJECT              = 0x0800,
    TARGET_FLAG_TRADE_ITEM          = 0x1000,
    TARGET_FLAG_STRING              = 0x2000,
    TARGET_FLAG_PET_DEST_LOCATION   = 0x4000,
    TARGET_FLAG_CORPSE2             = 0x8000
};

enum procFlags
{
	PROC_NULL							= 0x0,
	PROC_ON_CAST_SPELL_EVENT			= 0x1,
	PROC_ON_GAIN_EXPIERIENCE_EVENT		= 0x2,
	PROC_ON_MELEE_ATTACK_EVENT			= 0x4,
	PROC_ON_RANGED_ATTACK_EVENT			= 0x8,
	PROC_ON_SPELL_HIT_EVENT				= 0x10,		
	PROC_ON_IMMUNE_EVENT				= 0x20,
	PROC_ON_PRE_DISPELL_AURA_CASTER_EVENT		= 0x40,
	PROC_ON_HEAL_EVENT					= 0x80,
	PROC_ON_BLOCK_EVENT					= 0x100,
	PROC_ON_TRAP_TRIGGER_EVENT			= 0x200,
	PROC_ON_AURA_REMOVE_EVENT			= 0x400,
	PROC_ON_ABSORB_EVENT				= 0x800,
	PROC_ON_RESIST_EVENT				= 0x1000,
	PROC_ON_DODGE_EVENT					= 0x2000,
	PROC_ON_DIE_EVENT					= 0x4000,
	PROC_ON_INTERRUPT_EVENT				= 0x8000,
	PROC_ON_RUNE_DEPLETE_EVENT			= 0x10000,
	PROC_ON_PRE_CAST_SPELL_EVENT		= 0x20000,
	PROC_ON_REFLECT_EVENT				= 0x40000,
#define NUMBER_OF_EVENT_FLAGS_USED		19
//	PROC_ON_NO_CRIT						= 0x80000,		
//	PROC_ON_VICTIM						= 0x100000,		
//	PROC_ON_TRAP_TRIGGER				= 0x200000,		
//	PROC_ON_AURA_REMOVE					= 0x400000,
//	PROC_ON_DISABLED					= 0x800000,		//filter flag. This will never be added to flags and will make the proc never fire
	PROC_ON_FIRST_TICK					= 0x1000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
	PROC_ON_NO_CRIT						= 0x2000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
	PROC_ON_CRIT						= 0x4000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
	PROC_ON_NOT_VICTIM					= 0x8000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
	PROC_ON_VICTIM						= 0x10000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
	PROC_ON_NO_DOT						= 0x20000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
	PROC_ON_DOT							= 0x40000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
	PROC_OFFHAND_WEAPON					= 0x80000000,	//filter flag. If original spell has it, then proc event must have it also ( non conditional )
};

//If spell has one of these then event must have one of these. These flags cannot proc the spell. They can only stop it from proccing
#define PROC_EVENT_FILTER_FLAGS					( PROC_ON_NO_CRIT | PROC_ON_CRIT | PROC_ON_NOT_VICTIM | PROC_ON_VICTIM | PROC_ON_NO_DOT | PROC_ON_DOT | PROC_OFFHAND_WEAPON )
//If spell has one of these then event must have one of these. These flags cannot proc the spell. They can only stop it from proccing
#define PROC_EVENT_PROC_FLAGS					( ~PROC_EVENT_FILTER_FLAGS )

#define PROC_ON_PRE_CAST_SPELL					( PROC_ON_PRE_CAST_SPELL_EVENT | PROC_ON_NOT_VICTIM )	
#define PROC_ON_CAST_SPELL						( PROC_ON_CAST_SPELL_EVENT | PROC_ON_NOT_VICTIM )	
#define PROC_ON_MELEE_ATTACK					( PROC_ON_MELEE_ATTACK_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_RANGED_ATTACK					( PROC_ON_RANGED_ATTACK_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_SPELL_HIT						( PROC_ON_SPELL_HIT_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_SPELL_HIT_DOT					( PROC_ON_SPELL_HIT_EVENT | PROC_ON_DOT | PROC_ON_NOT_VICTIM )
#define PROC_ON_ANY_DAMAGE_DONE					( PROC_ON_MELEE_ATTACK_EVENT | PROC_ON_RANGED_ATTACK_EVENT | PROC_ON_SPELL_HIT_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_ANY_SPELL_DAMAGE_DONE			( PROC_ON_SPELL_HIT_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_ANY_NON_SPELL_DAMAGE_DONE		( PROC_ON_MELEE_ATTACK_EVENT | PROC_ON_RANGED_ATTACK_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_HEAL							( PROC_ON_HEAL_EVENT | PROC_ON_NOT_VICTIM )
#define	PROC_ON_HEAL_SPELL						( PROC_ON_HEAL_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_HEAL_DOT						( PROC_ON_HEAL_EVENT | PROC_ON_DOT | PROC_ON_NOT_VICTIM )
#define PROC_ON_AURA_REMOVE						( PROC_ON_AURA_REMOVE_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_GAIN_EXPIERIENCE				( PROC_ON_GAIN_EXPIERIENCE_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_BLOCK							( PROC_ON_BLOCK_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_IMMUNE							( PROC_ON_IMMUNE_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_TRAP_TRIGGER					( PROC_ON_TRAP_TRIGGER_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_ABSORB							( PROC_ON_ABSORB_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_RESIST							( PROC_ON_RESIST_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_DODGE							( PROC_ON_DODGE_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_TARGET_DIE						( PROC_ON_DIE_EVENT | PROC_ON_NOT_VICTIM )
#define PROC_ON_PRE_DISPELL_AURA_CASTER			( PROC_ON_PRE_DISPELL_AURA_CASTER_EVENT | PROC_ON_NOT_VICTIM )

#define PROC_ON_CRIT_ATTACK						( PROC_ON_MELEE_ATTACK | PROC_ON_CRIT )
#define PROC_ON_SPELL_CRIT_HIT					( PROC_ON_SPELL_HIT | PROC_ON_CRIT )
#define PROC_ON_RANGED_CRIT_ATTACK				( PROC_ON_RANGED_ATTACK | PROC_ON_CRIT )
#define PROC_ON_HEAL_CRIT						( PROC_ON_HEAL_EVENT | PROC_ON_CRIT | PROC_ON_NOT_VICTIM )

#define PROC_ON_PRE_SPELL_LAND_VICTIM			( PROC_ON_PRE_CAST_SPELL_EVENT | PROC_ON_VICTIM )	
#define PROC_ON_SPELL_LAND_VICTIM				( PROC_ON_CAST_SPELL_EVENT | PROC_ON_VICTIM )
#define PROC_ON_MELEE_ATTACK_VICTIM				( PROC_ON_MELEE_ATTACK_EVENT | PROC_ON_VICTIM )
#define PROC_ON_RANGED_ATTACK_VICTIM			( PROC_ON_RANGED_ATTACK_EVENT | PROC_ON_VICTIM )
#define PROC_ON_SPELL_HIT_VICTIM_NOT_DOT		( PROC_ON_SPELL_HIT_EVENT | PROC_ON_VICTIM | PROC_ON_NO_DOT )
#define PROC_ON_SPELL_HIT_VICTIM_DOT			( PROC_ON_SPELL_HIT_EVENT | PROC_ON_DOT | PROC_ON_VICTIM )
#define PROC_ON_ANY_DAMAGE_VICTIM				( PROC_ON_MELEE_ATTACK_EVENT | PROC_ON_RANGED_ATTACK_EVENT | PROC_ON_SPELL_HIT_EVENT | PROC_ON_VICTIM )
#define PROC_ON_ANY_SPELL_DAMAGE_VICTIM			( PROC_ON_SPELL_HIT_EVENT | PROC_ON_VICTIM )
#define PROC_ON_ANY_NON_SPELL_DAMAGE_DONE_VICTIM ( PROC_ON_MELEE_ATTACK_EVENT | PROC_ON_RANGED_ATTACK_EVENT | PROC_ON_VICTIM )
#define PROC_ON_HEAL_VICTIM						( PROC_ON_HEAL_EVENT | PROC_ON_VICTIM )
#define PROC_ON_DODGE_VICTIM					( PROC_ON_DODGE_EVENT | PROC_ON_VICTIM )
#define PROC_ON_BLOCK_VICTIM					( PROC_ON_BLOCK_EVENT | PROC_ON_VICTIM )
#define PROC_ON_RESIST_VICTIM					( PROC_ON_RESIST_EVENT | PROC_ON_VICTIM )
#define PROC_ON_IMMUNE_VICTIM					( PROC_ON_IMMUNE_EVENT | PROC_ON_VICTIM )
#define PROC_ON_PRE_DISPELL_AURA_VICTIM_CASTER	( PROC_ON_PRE_DISPELL_AURA_CASTER_EVENT | PROC_ON_VICTIM )
#define	PROC_ON_ABSORB_VICTIM					( PROC_ON_ABSORB_EVENT | PROC_ON_VICTIM )
#define PROC_ON_DIE_VICTIM						( PROC_ON_DIE_EVENT | PROC_ON_VICTIM )

#define PROC_ON_CRIT_HIT_VICTIM					( PROC_ON_MELEE_ATTACK_EVENT | PROC_ON_VICTIM | PROC_ON_CRIT )
#define PROC_ON_RANGED_CRIT_ATTACK_VICTIM		( PROC_ON_RANGED_ATTACK_EVENT | PROC_ON_VICTIM | PROC_ON_CRIT )
#define PROC_ON_SPELL_CRIT_HIT_VICTIM			( PROC_ON_SPELL_HIT_EVENT | PROC_ON_NO_DOT | PROC_ON_VICTIM | PROC_ON_CRIT )
#define PROC_ON_HEAL_CRIT_VICTIM				( PROC_ON_HEAL_EVENT | PROC_ON_VICTIM | PROC_ON_CRIT )


enum procFlags2
{
	PROC2_REMOVEONUSE					= 0x00000001,//remove prochcharge only when it is used
	PROC2_TARGET_SELF					= 0x00000002,//our custom flag to decide if proc target is self or victim
};

enum CastInterruptFlags
{
    CAST_INTERRUPT_NULL            = 0x0,
    CAST_INTERRUPT_ON_SILENCE      = 0x1,
    CAST_INTERRUPT_PUSHBACK        = 0x2, // seems to be whether or not the spell is pushed back on dmg
    CAST_INTERRUPT_ON_STUNNED      = 0x4, // could be wrong
    CAST_INTERRUPT_ON_MOVEMENT     = 0x8,
    CAST_INTERRUPT_ON_DAMAGE_TAKEN = 0x10
};

enum AuraInterruptFlags
{
    AURA_INTERRUPT_NULL									= 0x0,
    AURA_INTERRUPT_ON_HOSTILE_SPELL_INFLICTED			= 0x1,
    AURA_INTERRUPT_ON_ANY_DAMAGE_TAKEN					= 0x2,
    AURA_INTERRUPT_ON_CAST								= 0x4,
    AURA_INTERRUPT_ON_MOVEMENT							= 0x8,
    AURA_INTERRUPT_ON_TURNING							= 0x10,
    AURA_INTERRUPT_ON_ENTER_COMBAT						= 0x20,		//jump ?
    AURA_INTERRUPT_ON_DISMOUNT							= 0x40,
    AURA_INTERRUPT_ON_ENTER_WATER						= 0x80,
    AURA_INTERRUPT_ON_LEAVE_WATER						= 0x100, // could be AURA_INTERRUPT_ON_LEAVE_CURRENT_SURFACE
    AURA_INTERRUPT_ON_ANY_DAMAGE_TAKEN_35_PCT_CHANCE    = 0x200,	//weaponsheath
    AURA_INTERRUPT_ON_ACTION_WITH_NPC					= 0x400,
    AURA_INTERRUPT_ON_USE_OBJECT						= 0x800,
    AURA_INTERRUPT_ON_START_ATTACK						= 0x1000,
    AURA_INTERRUPT_ON_START_ATTCK_SPELL					= 0x2000,
    AURA_INTERRUPT_ON_UNUSED3							= 0x4000,
    AURA_INTERRUPT_ON_CAST_SPELL						= 0x8000,	//transform ?
    AURA_INTERRUPT_ON_UNK7								= 0x10000,
    AURA_INTERRUPT_ON_MOUNT								= 0x20000,
    AURA_INTERRUPT_ON_STAND_UP							= 0x40000,
    AURA_INTERRUPT_ON_LEAVE_AREA						= 0x80000,
    AURA_INTERRUPT_ON_INVINCIBLE						= 0x100000,
    AURA_INTERRUPT_ON_STEALTH							= 0x200000,
    AURA_INTERRUPT_ON_TELEPORTED						= 0x400000,
	AURA_INTERRUPT_ON_PVP_ENTER							= 0x800000,
	AURA_INTERRUPT_ON_DIRECT_DAMAGE						= 0x1000000,
//    AURA_INTERRUPT_CUSTOM_ZERO_DMG						= 0x40000000,	//sap and blind should break even if we do not do dmg to them ?
    AURA_INTERRUPT_CUSTOM_ON_PVP						= 0x80000000,
};

enum ChannelInterruptFlags
{
    CHANNEL_INTERRUPT_NULL  = 0x0,
    CHANNEL_INTERRUPT_ON_1  = 0x1,
    CHANNEL_INTERRUPT_ON_2  = 0x2,
    CHANNEL_INTERRUPT_ON_3  = 0x4,
    CHANNEL_INTERRUPT_ON_4  = 0x8,
    CHANNEL_INTERRUPT_ON_5  = 0x10,
    CHANNEL_INTERRUPT_ON_6  = 0x20,
    CHANNEL_INTERRUPT_ON_7  = 0x40,
    CHANNEL_INTERRUPT_ON_8  = 0x80,
    CHANNEL_INTERRUPT_ON_9  = 0x100,
    CHANNEL_INTERRUPT_ON_10 = 0x200,
    CHANNEL_INTERRUPT_ON_11 = 0x400,
    CHANNEL_INTERRUPT_ON_12 = 0x800,
    CHANNEL_INTERRUPT_ON_13 = 0x1000,
    CHANNEL_INTERRUPT_ON_14 = 0x2000,
    CHANNEL_INTERRUPT_ON_15 = 0x4000,
    CHANNEL_INTERRUPT_ON_16 = 0x8000,
    CHANNEL_INTERRUPT_ON_17 = 0x10000,
    CHANNEL_INTERRUPT_ON_18 = 0x20000
};

enum TIMER_TYPE
{
	TIMER_EXHAUSTION,
	TIMER_BREATH,
	TIMER_FEIGNDEATH,
	TIMER_UNKNOWN
};

enum Attributes
{
	ATTRIBUTES_NULL								= 0x0,
	ATTRIBUTES_UNK2								= 0x1,
	ATTRIBUTES_UNK3								= 0x2, // related to ranged??
	ATTRIBUTE_ON_NEXT_ATTACK					= 0x4,
	ATTRIBUTES_UNUSED0							= 0x8,
	ATTRIBUTES_UNK6								= 0x10,
	ATTRIBUTES_UNK7								= 0x20, // Tradeskill recipies
	ATTRIBUTES_PASSIVE							= 0x40,
	ATTRIBUTES_NO_VISUAL_AURA					= 0x80,
	ATTRIBUTES_NO_CAST							= 0x100,	//seems to be afflicts pet
	ATTRIBUTES_UNK11							= 0x200, // looks like temp enchants.
	ATTRIBUTES_UNK12							= 0x400, //completely the same as ATTRIBUTE_ON_NEXT_ATTACK for class spells. So difference somewhere in mob abilities.
	ATTRIBUTES_UNK13							= 0x800,
	ATTRIBUTES_UNUSED1							= 0x1000,
	ATTRIBUTES_UNUSED2							= 0x2000,
	ATTRIBUTES_UNUSED3							= 0x4000,
	ATTRIBUTES_ONLY_OUTDOORS					= 0x8000,
	ATTRIBUTES_UNK								= 0x10000,
	ATTRIBUTES_REQ_STEALTH						= 0x20000,
	ATTRIBUTES_UNK20							= 0x40000,//it's not : must be behind
	ATTRIBUTES_UNK21							= 0x80000,
	ATTRIBUTES_STOP_ATTACK						= 0x100000,//switch off auto attack on use. Maim,Gouge,Disengage,Polymorph etc
	ATTRIBUTES_CANT_BE_DPB				    	= 0x200000,//can't be dodged, blocked, parried
	ATTRIBUTES_UNK24							= 0x400000, // related to ranged
	ATTRIBUTES_UNK25							= 0x800000,
	ATTRIBUTES_MOUNT_CASTABLE					= 0x1000000, //castable on mounts
	ATTRIBUTES_TRIGGER_COOLDOWN			        = 0x2000000, //also requires atributes ex = 32 ?
	ATTRIBUTES_UNK28							= 0x4000000,
	ATTRIBUTES_START_COOLDOWN_AFTER_COMBAT		= 0x8000000,	//it is present in potions that start cooldown after combat
	ATTRIBUTES_REQ_OOC							= 0x10000000, //     ATTRIBUTES_REQ_OUT_OF_COMBAT
    ATTRIBUTES_IGNORE_INVULNERABILITY           = 0x20000000, //debuffs that can't be removed by any spell and spells that can't be resisted in any case
	ATTRIBUTES_UNK32							= 0x40000000, // seems like IS_DIMINISHING but some spells not there (f.e. Gouge)
	ATTRIBUTES_CANT_CANCEL						= 0x80000000,	// seems like aura is not removeable by CMSG_CANCEL_AURA
};

enum AttributesEx
{
	ATTRIBUTESEX_NULL                         = 0x0, // 0
	ATTRIBUTESEX_UNK2                         = 0x1, // 1, pet summonings
	ATTRIBUTESEX_DRAIN_WHOLE_MANA             = 0x2, // 2
	ATTRIBUTESEX_UNK4                         = 0x4, // 3
	ATTRIBUTESEX_UNK5                         = 0x8, // 4
	ATTRIBUTESEX_UNK6                         = 0x10, // 5, stealth effects but Rockbiter wtf 0_0
	ATTRIBUTESEX_NOT_BREAK_STEALTH            = 0x20, // 6
	ATTRIBUTESEX_UNK8						  = 0x40, // 7 [POSSIBLY: dynamite, grenades from engineering etc..]
	ATTRIBUTESEX_UNK9                         = 0x80,
	ATTRIBUTESEX_REQ_OOC_TARGET               = 0x100,
	ATTRIBUTESEX_UNK11                        = 0x200,
	ATTRIBUTESEX_VISIBLE                      = 0x400,	//not dead sure
	ATTRIBUTESEX_UNK13                        = 0x800,
	ATTRIBUTESEX_UNK14                        = 0x1000, // related to pickpocket
	ATTRIBUTESEX_UNK15                        = 0x2000, // related to remote control
	ATTRIBUTESEX_UNK16                        = 0x4000,
	ATTRIBUTESEX_UNK17                        = 0x8000, // something like "grant immunity"
	ATTRIBUTESEX_UNK18                        = 0x10000, // something like "grant immunity" too
	ATTRIBUTESEX_REMAIN_OOC                   = 0x20000,
	ATTRIBUTESEX_UNK20                        = 0x40000,
	ATTRIBUTESEX_UNK21                        = 0x80000,
	ATTRIBUTESEX_UNK22                        = 0x100000, // related to "Finishing move" and "Instantly overpowers"
	ATTRIBUTESEX_UNK23                        = 0x200000,
	ATTRIBUTESEX_UNK24                        = 0x400000, // only related to "Finishing move"
	ATTRIBUTESEX_UNK25                        = 0x800000, // related to spells like "ClearAllBuffs"
	ATTRIBUTESEX_UNK26                        = 0x1000000, // FISHING SPELLS
	ATTRIBUTESEX_UNK27                        = 0x2000000, // related to "Detect" spell
	ATTRIBUTESEX_UNK28                        = 0x4000000,
	ATTRIBUTESEX_UNK29                        = 0x8000000,
	ATTRIBUTESEX_UNK30                        = 0x10000000,
	ATTRIBUTESEX_UNK31                        = 0x20000000,
	ATTRIBUTESEX_UNK32                        = 0x40000000, // Overpower
};

enum SpellAttr2
{
    SPELL_ATTR2_ALLOW_DEAD_TARGET                = 0x00000001, //  0
    SPELL_ATTR2_UNK1                             = 0x00000002, //  1 ? many triggered spells have this flag
    SPELL_ATTR2_CANT_REFLECTED                   = 0x00000004, //  2 ? used for detect can or not spell reflected
    SPELL_ATTR2_UNK3                             = 0x00000008, //  3
    SPELL_ATTR2_ALWAYS_APPLY_MODIFIERS           = 0x00000010, //  4 ? spell modifiers are applied dynamically (even if aura is not passive)
    SPELL_ATTR2_AUTOREPEAT_FLAG                  = 0x00000020, //  5
    SPELL_ATTR2_UNK6                             = 0x00000040, //  6
    SPELL_ATTR2_UNK7                             = 0x00000080, //  7
    SPELL_ATTR2_UNK8                             = 0x00000100, //  8 not set in 3.0.3
    SPELL_ATTR2_UNK9                             = 0x00000200, //  9
    SPELL_ATTR2_UNK10                            = 0x00000400, // 10
    SPELL_ATTR2_HEALTH_FUNNEL                    = 0x00000800, // 11
    SPELL_ATTR2_UNK12                            = 0x00001000, // 12
    SPELL_ATTR2_UNK13                            = 0x00002000, // 13 Items enchanted by spells with this flag preserve the enchant to arenas
    SPELL_ATTR2_UNK14                            = 0x00004000, // 14
    SPELL_ATTR2_UNK15                            = 0x00008000, // 15 not set in 3.0.3
    SPELL_ATTR2_TAME_BEAST                       = 0x00010000, // 16
    SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS           = 0x00020000, // 17 don't reset timers for melee autoattacks (swings) or ranged autoattacks (autoshoots)
    SPELL_ATTR2_UNK18                            = 0x00040000, // 18 Only Revive pet - possible req dead pet
    SPELL_ATTR2_NOT_NEED_SHAPESHIFT              = 0x00080000, // 19 does not necessarly need shapeshift
    SPELL_ATTR2_UNK20                            = 0x00100000, // 20
    SPELL_ATTR2_DAMAGE_REDUCED_SHIELD            = 0x00200000, // 21 for ice blocks, pala immunity buffs, priest absorb shields, but used also for other spells -> not sure!
    SPELL_ATTR2_UNK22                            = 0x00400000, // 22
    SPELL_ATTR2_UNK23                            = 0x00800000, // 23 Only mage Arcane Concentration have this flag
    SPELL_ATTR2_UNK24                            = 0x01000000, // 24
    SPELL_ATTR2_UNK25                            = 0x02000000, // 25
    SPELL_ATTR2_UNK26                            = 0x04000000, // 26 unaffected by school immunity
    SPELL_ATTR2_UNK27                            = 0x08000000, // 27
    SPELL_ATTR2_UNK28                            = 0x10000000, // 28 no breaks stealth if it fails??
    SPELL_ATTR2_CANT_CRIT                        = 0x20000000, // 29 Spell can't crit
    SPELL_ATTR2_TRIGGERED_CAN_TRIGGER            = 0x40000000, // 30 spell can trigger even if triggered
    SPELL_ATTR2_FOOD_BUFF                        = 0x80000000  // 31 Food or Drink Buff (like Well Fed)
};

enum SpellAttr3
{
    SPELL_ATTR3_UNK0                             = 0x00000001, //  0
    SPELL_ATTR3_UNK1                             = 0x00000002, //  1
    SPELL_ATTR3_UNK2                             = 0x00000004, //  2
    SPELL_ATTR3_BLOCKABLE_SPELL                  = 0x00000008, //  3 Only dmg class melee in 3.1.3
    SPELL_ATTR3_UNK4                             = 0x00000010, //  4 Druid Rebirth only this spell have this flag
    SPELL_ATTR3_UNK5                             = 0x00000020, //  5
    SPELL_ATTR3_UNK6                             = 0x00000040, //  6
    SPELL_ATTR3_STACK_FOR_DIFF_CASTERS           = 0x00000080, //  7 separate stack for every caster
    SPELL_ATTR3_PLAYERS_ONLY                     = 0x00000100, //  8 Player only?
    SPELL_ATTR3_TRIGGERED_CAN_TRIGGER_2          = 0x00000200, //  9 triggered from effect?
    SPELL_ATTR3_MAIN_HAND                        = 0x00000400, // 10 Main hand weapon required
    SPELL_ATTR3_BATTLEGROUND                     = 0x00000800, // 11 Can casted only on battleground
    SPELL_ATTR3_REQUIRE_DEAD_TARGET              = 0x00001000, // 12
    SPELL_ATTR3_UNK13                            = 0x00002000, // 13
    SPELL_ATTR3_UNK14                            = 0x00004000, // 14 "Honorless Target" only this spells have this flag
    SPELL_ATTR3_UNK15                            = 0x00008000, // 15 Auto Shoot, Shoot, Throw,  - this is autoshot flag
    SPELL_ATTR3_UNK16                            = 0x00010000, // 16 no triggers effects that trigger on casting a spell?? (15290 - 2.2ptr change)
    SPELL_ATTR3_NO_INITIAL_AGGRO                 = 0x00020000, // 17 Soothe Animal, 39758, Mind Soothe
    SPELL_ATTR3_UNK18                            = 0x00040000, // 18 added to Explosive Trap Effect 3.3.0, removed from Mutilate 3.3.0
    SPELL_ATTR3_DISABLE_PROC                     = 0x00080000, // 19 during aura proc no spells can trigger (20178, 20375)
    SPELL_ATTR3_DEATH_PERSISTENT                 = 0x00100000, // 20 Death persistent spells
    SPELL_ATTR3_UNK21                            = 0x00200000, // 21
    SPELL_ATTR3_REQ_WAND                         = 0x00400000, // 22 Req wand
    SPELL_ATTR3_UNK23                            = 0x00800000, // 23
    SPELL_ATTR3_REQ_OFFHAND                      = 0x01000000, // 24 Req offhand weapon
    SPELL_ATTR3_UNK25                            = 0x02000000, // 25 no cause spell pushback ?
    SPELL_ATTR3_CAN_PROC_TRIGGERED               = 0x04000000, // 26
    SPELL_ATTR3_DRAIN_SOUL                       = 0x08000000, // 27 only drain soul has this flag
    SPELL_ATTR3_UNK28                            = 0x10000000, // 28
    SPELL_ATTR3_NO_DONE_BONUS                    = 0x20000000, // 29 Ignore caster spellpower and done damage mods?
    SPELL_ATTR3_UNK30                            = 0x40000000, // 30 Shaman's Fire Nova 3.3.0, Sweeping Strikes 3.3.0
    SPELL_ATTR3_UNK31                            = 0x80000000  // 31
};

enum SpellAttr4
{
    SPELL_ATTR4_UNK0                             = 0x00000001, //  0
    SPELL_ATTR4_UNK1                             = 0x00000002, //  1 proc on finishing move?
    SPELL_ATTR4_UNK2                             = 0x00000004, //  2
    SPELL_ATTR4_CANT_PROC_FROM_SELFCAST          = 0x00000008, //  3
    SPELL_ATTR4_UNK4                             = 0x00000010, //  4 This will no longer cause guards to attack on use??
    SPELL_ATTR4_UNK5                             = 0x00000020, //  5
    SPELL_ATTR4_NOT_STEALABLE                    = 0x00000040, //  6 although such auras might be dispellable, they cannot be stolen
    SPELL_ATTR4_TRIGGERED                        = 0x00000080, //  7 spells forced to be triggered
    SPELL_ATTR4_FIXED_DAMAGE                     = 0x00000100, //  8 decimate, share damage?
    SPELL_ATTR4_UNK9                             = 0x00000200, //  9
    SPELL_ATTR4_SPELL_VS_EXTEND_COST             = 0x00000400, // 10 Rogue Shiv have this flag
    SPELL_ATTR4_UNK11                            = 0x00000800, // 11
    SPELL_ATTR4_UNK12                            = 0x00001000, // 12
    SPELL_ATTR4_UNK13                            = 0x00002000, // 13
    SPELL_ATTR4_UNK14                            = 0x00004000, // 14
    SPELL_ATTR4_UNK15                            = 0x00008000, // 15
    SPELL_ATTR4_NOT_USABLE_IN_ARENA              = 0x00010000, // 16 not usable in arena
    SPELL_ATTR4_USABLE_IN_ARENA                  = 0x00020000, // 17 usable in arena
    SPELL_ATTR4_UNK18                            = 0x00040000, // 18
    SPELL_ATTR4_UNK19                            = 0x00080000, // 19
    SPELL_ATTR4_NOT_CHECK_SELFCAST_POWER         = 0x00100000, // 20 supersedes message "More powerful spell applied" for self casts.
    SPELL_ATTR4_UNK21                            = 0x00200000, // 21
    SPELL_ATTR4_UNK22                            = 0x00400000, // 22
    SPELL_ATTR4_UNK23                            = 0x00800000, // 23
    SPELL_ATTR4_UNK24                            = 0x01000000, // 24
    SPELL_ATTR4_UNK25                            = 0x02000000, // 25 pet scaling auras
    SPELL_ATTR4_CAST_ONLY_IN_OUTLAND             = 0x04000000, // 26 Can only be used in Outland.
    SPELL_ATTR4_UNK27                            = 0x08000000, // 27
    SPELL_ATTR4_UNK28                            = 0x10000000, // 28
    SPELL_ATTR4_UNK29                            = 0x20000000, // 29
    SPELL_ATTR4_UNK30                            = 0x40000000, // 30
    SPELL_ATTR4_UNK31                            = 0x80000000  // 31
};

enum SpellAttr5
{
    SPELL_ATTR5_UNK0                             = 0x00000001, //  0
    SPELL_ATTR5_NO_REAGENT_WHILE_PREP            = 0x00000002, //  1 not need reagents if UNIT_FLAG_PREPARATION
    SPELL_ATTR5_UNK2                             = 0x00000004, //  2
    SPELL_ATTR5_USABLE_WHILE_STUNNED             = 0x00000008, //  3 usable while stunned
    SPELL_ATTR5_UNK4                             = 0x00000010, //  4
    SPELL_ATTR5_SINGLE_TARGET_SPELL              = 0x00000020, //  5 Only one target can be apply at a time
    SPELL_ATTR5_UNK6                             = 0x00000040, //  6
    SPELL_ATTR5_UNK7                             = 0x00000080, //  7
    SPELL_ATTR5_UNK8                             = 0x00000100, //  8
    SPELL_ATTR5_START_PERIODIC_AT_APPLY          = 0x00000200, //  9  begin periodic tick at aura apply
    SPELL_ATTR5_UNK10                            = 0x00000400, // 10
    SPELL_ATTR5_UNK11                            = 0x00000800, // 11
    SPELL_ATTR5_UNK12                            = 0x00001000, // 12
    SPELL_ATTR5_HASTE_AFFECT_DURATION            = 0x00002000, // 13 haste effects decrease duration of this
    SPELL_ATTR5_UNK14                            = 0x00004000, // 14
    SPELL_ATTR5_UNK15                            = 0x00008000, // 15
    SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK         = 0x00010000, // 16 this allows spells with EquippedItemClass to affect spells from other items if the required item is equipped
    SPELL_ATTR5_USABLE_WHILE_FEARED              = 0x00020000, // 17 usable while feared
    SPELL_ATTR5_USABLE_WHILE_CONFUSED            = 0x00040000, // 18 usable while confused
    SPELL_ATTR5_UNK19                            = 0x00080000, // 19
    SPELL_ATTR5_UNK20                            = 0x00100000, // 20
    SPELL_ATTR5_UNK21                            = 0x00200000, // 21
    SPELL_ATTR5_UNK22                            = 0x00400000, // 22
    SPELL_ATTR5_UNK23                            = 0x00800000, // 23
    SPELL_ATTR5_UNK24                            = 0x01000000, // 24
    SPELL_ATTR5_UNK25                            = 0x02000000, // 25
    SPELL_ATTR5_UNK26                            = 0x04000000, // 26
    SPELL_ATTR5_UNK27                            = 0x08000000, // 27
    SPELL_ATTR5_UNK28                            = 0x10000000, // 28
    SPELL_ATTR5_UNK29                            = 0x20000000, // 29
    SPELL_ATTR5_UNK30                            = 0x40000000, // 30
    SPELL_ATTR5_UNK31                            = 0x80000000  // 31 Forces all nearby enemies to focus attacks caster
};

enum SpellAttr6
{
    SPELL_ATTR6_UNK0                             = 0x00000001, //  0 Only Move spell have this flag
    SPELL_ATTR6_ONLY_IN_ARENA                    = 0x00000002, //  1 only usable in arena
    SPELL_ATTR6_IGNORE_CASTER_AURAS              = 0x00000004, //  2
    SPELL_ATTR6_UNK3                             = 0x00000008, //  3
    SPELL_ATTR6_UNK4                             = 0x00000010, //  4
    SPELL_ATTR6_UNK5                             = 0x00000020, //  5
    SPELL_ATTR6_UNK6                             = 0x00000040, //  6
    SPELL_ATTR6_UNK7                             = 0x00000080, //  7
    SPELL_ATTR6_IGNORE_CROWD_CONTROL_TARGETS     = 0x00000100, //  8
    SPELL_ATTR6_UNK9                             = 0x00000200, //  9
    SPELL_ATTR6_UNK10                            = 0x00000400, // 10
    SPELL_ATTR6_NOT_IN_RAID_INSTANCE             = 0x00000800, // 11 not usable in raid instance
    SPELL_ATTR6_UNK12                            = 0x00001000, // 12
    SPELL_ATTR6_UNK13                            = 0x00002000, // 13
    SPELL_ATTR6_UNK14                            = 0x00004000, // 14
    SPELL_ATTR6_UNK15                            = 0x00008000, // 15 not set in 3.0.3
    SPELL_ATTR6_UNK16                            = 0x00010000, // 16
    SPELL_ATTR6_UNK17                            = 0x00020000, // 17
    SPELL_ATTR6_UNK18                            = 0x00040000, // 18
    SPELL_ATTR6_UNK19                            = 0x00080000, // 19
    SPELL_ATTR6_UNK20                            = 0x00100000, // 20
    SPELL_ATTR6_CLIENT_UI_TARGET_EFFECTS         = 0x00200000, // 21 it's only client-side attribute
    SPELL_ATTR6_UNK22                            = 0x00400000, // 22
    SPELL_ATTR6_UNK23                            = 0x00800000, // 23 not set in 3.0.3
    SPELL_ATTR6_UNK24                            = 0x01000000, // 24 not set in 3.0.3
    SPELL_ATTR6_UNK25                            = 0x02000000, // 25 not set in 3.0.3
    SPELL_ATTR6_UNK26                            = 0x04000000, // 26 not set in 3.0.3
    SPELL_ATTR6_UNK27                            = 0x08000000, // 27 not set in 3.0.3
    SPELL_ATTR6_UNK28                            = 0x10000000, // 28 not set in 3.0.3
    SPELL_ATTR6_UNK29                            = 0x20000000, // 29 not set in 3.0.3
    SPELL_ATTR6_UNK30                            = 0x40000000, // 30 not set in 3.0.3
    SPELL_ATTR6_UNK31                            = 0x80000000  // 31 not set in 3.0.3
};

enum SpellAttr7
{
    SPELL_ATTR7_UNK0                             = 0x00000001, //  0 Shaman's new spells (Call of the ...), Feign Death.
    SPELL_ATTR7_UNK1                             = 0x00000002, //  1 Not set in 3.2.2a.
    SPELL_ATTR7_REACTIVATE_AT_RESURRECT          = 0x00000004, //  2 Paladin's auras and 65607 only.
    SPELL_ATTR7_DISABLED_CLIENT_SIDE             = 0x00000008, //  3 used only by client to disable spells client-side. some sort of special player flag (0x40000) bypasses that restriction
    SPELL_ATTR7_UNK4                             = 0x00000010, //  4 Only 66109 test spell.
    SPELL_ATTR7_SUMMON_PLAYER_TOTEM              = 0x00000020, //  5 Only Shaman player totems.
    SPELL_ATTR7_UNK6                             = 0x00000040, //  6 Dark Surge, Surge of Light, Burning Breath triggers (boss spells).
    SPELL_ATTR7_UNK7                             = 0x00000080, //  7 66218 (Launch) spell.
    SPELL_ATTR7_UNK8                             = 0x00000100, //  8 Teleports, mounts and other spells.
    SPELL_ATTR7_UNK9                             = 0x00000200, //  9 Teleports, mounts and other spells.
    SPELL_ATTR7_DISPEL_CHARGES                   = 0x00000400, // 10 Dispel and Spellsteal individual charges instead of whole aura.
    SPELL_ATTR7_INTERRUPT_ONLY_NONPLAYER         = 0x00000800, // 11 Only non-player casts interrupt, though Feral Charge - Bear has it.
    SPELL_ATTR7_UNK12                            = 0x00001000, // 12 Not set in 3.2.2a.
    SPELL_ATTR7_UNK13                            = 0x00002000, // 13 Not set in 3.2.2a.
    SPELL_ATTR7_UNK14                            = 0x00004000, // 14 Only 52150 (Raise Dead - Pet) spell.
    SPELL_ATTR7_UNK15                            = 0x00008000, // 15 Exorcism. Usable on players? 100% crit chance on undead and demons?
    SPELL_ATTR7_UNK16                            = 0x00010000, // 16 Druid spells (29166, 54833, 64372, 68285).
    SPELL_ATTR7_UNK17                            = 0x00020000, // 17 Only 27965 (Suicide) spell.
    SPELL_ATTR7_HAS_CHARGE_EFFECT                = 0x00040000, // 18 Only spells that have Charge among effects.
    SPELL_ATTR7_ZONE_TELEPORT                    = 0x00080000  // 19 Teleports to specific zones.
};

enum Flags3
{
	FLAGS3_NULL               = 0x0,
	FLAGS3_UNK2               = 0x1,
	FLAGS3_UNK3               = 0x2,    // Can be used while stealthed
	FLAGS3_UNK4               = 0x4,    // request pet maybe
	FLAGS3_UNK5               = 0x8,    // something todo with temp enchanted items
	FLAGS3_PARTY_EFFECTING_AURA = 0x10, // Party affecting aura's
	FLAGS3_ACTIVATE_AUTO_SHOT = 0x20,   // spell that enable's auto shoot
	FLAGS3_UNK8               = 0x40,   //Polymorph spells
	FLAGS3_UNK9               = 0x80,
	FLAGS3_UNUSED1            = 0x100,
	FLAGS3_UNK11              = 0x200,  // used by 2 spells, 30421 | Nether Portal - Perseverence and  30466 | Nether Portal - Perseverence
	FLAGS3_TAME_X             = 0x400,  // tame [creature]
	FLAGS3_FUNNEL             = 0x800,  // only funnel spells
	FLAGS3_UNK14              = 0x1000, // swipe / Cleave spells
	FLAGS3_ENCHANT_OWN_ONLY   = 0x2000, // no trade window targets, BoE items get soulbound to you
	FLAGS3_SPELL_PLAYER_EVENT = 0x4000, // Player event's like logging in, finishing quests, triggering cinematic, being adored, Heartbroken etc
	FLAGS3_UNUSED3            = 0x8000,
	FLAGS3_CONTROL_UNIT       = 0x10000, // PvP Controller, RC, Creature taming, Taming Lesson
	FLAGS3_REQ_RANGED_WEAPON  = 0x20000, // this is shit and has nothing to do with auto shot
	FLAGS3_REVIVE_PET         = 0x40000, // actually 1 spell, revive pet
	FLAGS3_UNK21              = 0x80000, // this is a group of spells that are triggered by something. (I have no clue on how to name this one)
	FLAGS3_REQ_BEHIND_TARGET  = 0x100000, //wrong
	FLAGS3_UNK23              = 0x200000,
	FLAGS3_UNK24              = 0x400000,
	FLAGS3_UNK25              = 0x800000,
	FLAGS3_UNK26              = 0x1000000,
	FLAGS3_UNK27              = 0x2000000,
	FLAGS3_UNK28              = 0x4000000,
	FLAGS3_UNK29              = 0x8000000, // fishing spells and enchanting weapons
	FLAGS3_UNK30              = 0x10000000, // some secondairy spell triggers, especialy for lightning shield alike spells
	FLAGS3_UNK31              = 0x20000000,
	FLAGS3_UNK32              = 0x40000000,
};

enum CasterFacingFlags
{
	CASTER_FACE_NO_REQ			= 0,
	CASTER_FACE_FACING			= 1,
	CASTER_FACE_FACING_WIDE		= 2,
	CASTER_FACE_FACING_WIDE2	= 4,
	CASTER_FACE_LOCATION		= 8,
	TARGET_FACE_CASTER			= 0x10000000,	//!!custom
	CASTER_FACE_TARGET			= 0x20000000,	//!!custom
};

enum Flags4
{
	FLAGS4_NULL							= 0x0,
	FLAGS4_UNK2							= 0x1,
	FLAGS4_UNK3							= 0x2,
	FLAGS4_UNK4							= 0x4,
	FLAGS4_UNK5							= 0x8,
	FLAGS4_UNK6							= 0x10,
	FLAGS4_UNK7							= 0x20,
	FLAGS4_UNK8							= 0x40,
	FLAGS4_UNK9							= 0x80,
	FLAGS4_UNK10						= 0x100,
	FLAGS4_UNK11						= 0x200,
	FLAGS4_UNK12						= 0x400,
	FLAGS4_BG_ONLY                      = 0x800,
	FLAGS4_UNK14						= 0x1000,
	FLAGS4_UNK15						= 0x2000,
	FLAGS4_UNK16						= 0x4000,
	FLAGS4_PLAYER_RANGED_SPELLS         = 0x8000,
	FLAGS4_UNK18						= 0x10000,
	FLAGS4_UNK19						= 0x20000,
	FLAGS4_UNK20						= 0x40000,
	FLAGS4_UNK21						= 0x80000,
	CAN_PERSIST_AND_CASTED_WHILE_DEAD   = 0x100000,
	FLAGS4_UNK23						= 0x200000,
	FLAGS4_PLAYER_RANGED_WAND           = 0x400000,
	FLAGS4_UNK25						= 0x800000,
	FLAGS4_TYPE_OFFHAND					= 0x1000000,
	FLAGS4_UNK27						= 0x2000000,
	FLAGS4_UNK28						= 0x4000000,
	FLAGS4_UNK29						= 0x8000000,
	FLAGS4_UNK30						= 0x10000000,
	FLAGS4_UNK31						= 0x20000000,
	FLAGS4_UNK32						= 0x40000000,
	FLAGS4_UNK33						= 0x80000000,
};

enum Flags6
{
	FLAGS6_NULL							= 0x0,
	FLAGS6_UNK2							= 0x1,
	FLAGS6_REAGENT_REMOVAL				= 0x2,
	FLAGS6_UNK4							= 0x4,
	FLAGS6_UNK5							= 0x8,
	FLAGS6_UNK6							= 0x10,
	FLAGS6_UNK7							= 0x20,
	FLAGS6_UNK8							= 0x40,
	FLAGS6_UNK9							= 0x80,
	FLAGS6_UNK10						= 0x100,
	FLAGS6_UNK11						= 0x200,
	FLAGS6_UNK12						= 0x400,
	FLAGS6_UNK13						= 0x800,
	FLAGS6_UNK14						= 0x1000,
	FLAGS6_UNK15						= 0x2000,
	FLAGS6_UNK16						= 0x4000,
	FLAGS6_UNK17						= 0x8000,
	FLAGS6_UNK18						= 0x10000,
	FLAGS6_UNK19						= 0x20000,
	FLAGS6_UNK20						= 0x40000,
	FLAGS6_UNK21						= 0x80000,
	FLAGS6_UNK22						= 0x100000,
	FLAGS6_UNK23						= 0x200000,
	FLAGS6_UNK24						= 0x400000,
	FLAGS6_UNK25						= 0x800000,
	FLAGS6_UNK26						= 0x1000000,
	FLAGS6_UNK27						= 0x2000000,
	FLAGS6_UNK28						= 0x4000000,
	FLAGS6_UNK29						= 0x8000000,
	FLAGS6_UNK30						= 0x10000000,
	FLAGS6_UNK31						= 0x20000000,
	FLAGS6_UNK32						= 0x40000000,
	FLAGS6_UNK33						= 0x80000000,
};

enum Flags7
{
	FLAGS7_NULL							= 0x0,
	FLAGS7_UNK2							= 0x1,
	FLAGS7_UNUSED1						= 0x2, // unused 2.4.3
	FLAGS7_UNK4							= 0x4,
	FLAGS7_UNK5							= 0x8,
	FLAGS7_UNUSED2						= 0x10, // unused 2.4.3
	FLAGS7_UNK7							= 0x20,
	FLAGS7_UNK8							= 0x40,
	FLAGS7_UNK9							= 0x80,
	FLAGS7_UNK10						= 0x100,
	FLAGS7_UNUSED3						= 0x200, // unused 2.4.3
	FLAGS7_UNK12						= 0x400,
	FLAGS7_UNK13						= 0x800,
	FLAGS7_UNUSED4						= 0x1000, // unused 2.4.3
	FLAGS7_UNK15						= 0x2000,
	FLAGS7_UNUSED5						= 0x4000, // unused 2.4.3
	FLAGS7_UNUSED6						= 0x8000, // unused 2.4.3
	FLAGS7_UNUSED7						= 0x10000, // unused 2.4.3 - 20-33 also unused 2.4.3
	FLAGS7_UNK19						= 0x20000,
};

enum Flags5
{
	FLAGS5_PROCCHANCE_COMBOBASED        = 0x2,
	FLAGS5_ONLY_IN_OUTLANDS             = 0x4000000,
};

enum SpellCastFlags
{
    CAST_FLAG_UNKNOWN1           = 0x2,
    CAST_FLAG_UNKNOWN2           = 0x10, // no idea yet, i saw it in blizzard spell
    CAST_FLAG_AMMO               = 0x20 // load ammo display id (uint32) and ammo inventory type (uint32)
};

enum School
{
    SCHOOL_NORMAL = 0,
    SCHOOL_HOLY   = 1,
    SCHOOL_FIRE   = 2,
    SCHOOL_NATURE = 3,
    SCHOOL_FROST  = 4,
    SCHOOL_SHADOW = 5,
    SCHOOL_ARCANE = 6,
	SCHOOL_COUNT   
};

enum SchoolMasks
{
    SCHOOL_MASK_NORMAL = 1,
    SCHOOL_MASK_HOLY   = 2,
    SCHOOL_MASK_FIRE   = 4,
    SCHOOL_MASK_NATURE = 8,
    SCHOOL_MASK_FROST  = 16,
    SCHOOL_MASK_SHADOW = 32,
    SCHOOL_MASK_ARCANE = 64,
	SCHOOL_MASK_ANY_MAGICAL = ( SCHOOL_MASK_HOLY | SCHOOL_MASK_FIRE | SCHOOL_MASK_NATURE | SCHOOL_MASK_FROST | SCHOOL_MASK_SHADOW | SCHOOL_MASK_ARCANE ),
	SCHOOL_MASK_COUNT   
};

// converting schools for 2.4.0 client
static const uint32 g_spellSchoolConversionTable[SCHOOL_COUNT] = {
	1,				// SCHOOL_NORMAL
	2,				// SCHOOL_HOLY
	4,				// SCHOOL_FIRE
	8,				// SCHOOL_NATURE
	16,				// SCHOOL_FROST
	32,				// SCHOOL_SHADOW
	64,				// SCHOOL_ARCANE
};

enum ReplenishType
{
    REPLENISH_UNDEFINED = 0,
    REPLENISH_HEALTH    = 20,
    REPLENISH_MANA      = 21,
    REPLENISH_RAGE      = 22 //don't know if rage is 22 or what, but will do for now
};

enum SpellTargetType
{
    TARGET_TYPE_NULL       = 0x0,
    TARGET_TYPE_BEAST      = 0x1,
    TARGET_TYPE_DRAGONKIN  = 0x2,
    TARGET_TYPE_DEMON      = 0x4,
    TARGET_TYPE_ELEMENTAL  = 0x8,
    TARGET_TYPE_GIANT      = 0x10,
    TARGET_TYPE_UNDEAD     = 0x20,
    TARGET_TYPE_HUMANOID   = 0x40,
    TARGET_TYPE_CRITTER    = 0x80,
    TARGET_TYPE_MECHANICAL = 0x100,
};

/****************SpellExtraFlags*****************/
/* SpellExtraFlags defines                      */
/*                                              */
/* Used for infront check and other checks      */
/* when they are not in spell.dbc               */
/*                                              */
/************************************************/
#define SPELL_EXTRA_INFRONT 1
#define SPELL_EXTRA_BEHIND  2
#define SPELL_EXTRA_UNDEF0  4 // not used yet
#define SPELL_EXTRA_UNDEF1  8 // not used yet


/***************Ranged spellid*******************/
/* Note: These spell id's are checked for 2.0.x */
/************************************************/
#define SPELL_RANGED_GENERAL    3018
#define SPELL_RANGED_THROW      2764
#define SPELL_RANGED_WAND       5019

#pragma pack(push,1)
struct TeleportCoords
{
    uint32 id;
    uint32 mapId;
    float x;
    float y;
    float z;
};
#pragma pack(pop)

#define MAX_NUMBER_OF_SPELLS_FOR_TOTEM 3
struct TotemSpells
{ 
	TotemSpells()
	{
		for(int i=0;i<MAX_NUMBER_OF_SPELLS_FOR_TOTEM;i++)
			spells[i]=NULL;
	}
	SpellEntry *spells[MAX_NUMBER_OF_SPELLS_FOR_TOTEM]; 
};

//created by spells to add extra attacks
struct ExtraAttack
{
	ExtraAttack() 
	{ 
		next_proc_stamp = 0; 
		dmg_type = 0;	//MELEE
		add_dmg = 0;
		pct_dmg_mod = 0;
	};
	SpellEntry	*sp;			//should contain the ID and the proc interval here
	uint32		count;			//number of extra strikes. probably will be 1 all the time
	uint32		next_proc_stamp;	//avoid spamming extra strikes on extra strike
	int32		dmg_type;		//always weapon ?
	int32		add_dmg;		//always 0 ?
	int32		pct_dmg_mod;	//always 0 ?
	//maybe add conditions later like : below HP pct
};

enum LOCKTYPES{
    LOCKTYPE_PICKLOCK               =1,
    LOCKTYPE_HERBALISM              =2,
    LOCKTYPE_MINING                 =3,
    LOCKTYPE_DISARM_TRAP            =4,
    LOCKTYPE_OPEN                   =5,
    LOCKTYPE_TREASURE               =6,
    LOCKTYPE_CALCIFIED_ELVEN_GEMS   =7,
    LOCKTYPE_CLOSE                  =8,
    LOCKTYPE_ARM_TRAP               =9,
    LOCKTYPE_QUICK_OPEN             =10,
    LOCKTYPE_QUICK_CLOSE            =11,
    LOCKTYPE_OPEN_TINKERING         =12,
    LOCKTYPE_OPEN_KNEELING          =13,
    LOCKTYPE_OPEN_ATTACKING         =14,
    LOCKTYPE_GAHZRIDIAN             =15,
    LOCKTYPE_BLASTING               =16,
    LOCKTYPE_SLOW_OPEN              =17,
    LOCKTYPE_SLOW_CLOSE             =18,
    LOCKTYPE_FISHING               = 19,
    LOCKTYPE_INSCRIPTION           = 20,
    LOCKTYPE_OPEN_FROM_VEHICLE     = 21,
	LOCKTYPE_ARCHAEOLOGY           = 22,
	LOCKTYPE_PVP_OPEN_FAST         = 23,
};

enum TotemCategory
{
    TOTEM_CATEGORY_SKINNING_SKIFE_OLD          = 1,
    TOTEM_CATEGORY_EARTH_TOTEM                 = 2,
    TOTEM_CATEGORY_AIR_TOTEM                   = 3,
    TOTEM_CATEGORY_FIRE_TOTEM                  = 4,
    TOTEM_CATEGORY_WATER_TOTEM                 = 5,
    TOTEM_CATEGORY_COPPER_ROD                  = 6,
    TOTEM_CATEGORY_SILVER_ROD                  = 7,
    TOTEM_CATEGORY_GOLDEN_ROD                  = 8,
    TOTEM_CATEGORY_TRUESILVER_ROD              = 9,
    TOTEM_CATEGORY_ARCANITE_ROD                = 10,
    TOTEM_CATEGORY_MINING_PICK_OLD             = 11,
    TOTEM_CATEGORY_PHILOSOPHERS_STONE          = 12,
    TOTEM_CATEGORY_BLACKSMITH_HAMMER_OLD       = 13,
    TOTEM_CATEGORY_ARCLIGHT_SPANNER            = 14,
    TOTEM_CATEGORY_GYROMATIC_MA                = 15,
    TOTEM_CATEGORY_MASTER_TOTEM                = 21,
    TOTEM_CATEGORY_FEL_IRON_ROD                = 41,
    TOTEM_CATEGORY_ADAMANTITE_ROD              = 62,
    TOTEM_CATEGORY_ETERNIUM_ROD                = 63,
    TOTEM_CATEGORY_HOLLOW_QUILL                = 81,
    TOTEM_CATEGORY_RUNED_AZURITE_ROD           = 101,
    TOTEM_CATEGORY_VIRTUOSO_INKING_SET         = 121,
    TOTEM_CATEGORY_DRUMS                       = 141,
    TOTEM_CATEGORY_GNOMISH_ARMY_KNIFE          = 161,
    TOTEM_CATEGORY_BLACKSMITH_HAMMER           = 162,
    TOTEM_CATEGORY_MINING_PICK                 = 165,
    TOTEM_CATEGORY_SKINNING_KNIFE              = 166,
    TOTEM_CATEGORY_HAMMER_PICK                 = 167,
    TOTEM_CATEGORY_BLADED_PICKAXE              = 168,
    TOTEM_CATEGORY_FLINT_AND_TINDER            = 169,
    TOTEM_CATEGORY_RUNED_COBALT_ROD            = 189,
    TOTEM_CATEGORY_RUNED_TITANIUM_ROD          = 190,
    TOTEM_CATEGORY_RUNED_ELEMENTIUM_ROD        = 209,
    TOTEM_CATEGORY_HIGH_POWERED_BOLT_GUN       = 210
};

enum SpellEffects
{
	SPELL_EFFECT_NULL = 0,
	SPELL_EFFECT_INSTANT_KILL,              //    1
	SPELL_EFFECT_SCHOOL_DAMAGE,             //    2
	SPELL_EFFECT_DUMMY,                     //    3
	SPELL_EFFECT_PORTAL_TELEPORT,           //    4
	SPELL_EFFECT_TELEPORT_UNITS,            //    5
	SPELL_EFFECT_APPLY_AURA,                //    6
	SPELL_EFFECT_ENVIRONMENTAL_DAMAGE,      //    7
	SPELL_EFFECT_POWER_DRAIN,               //    8
	SPELL_EFFECT_HEALTH_LEECH,              //    9
	SPELL_EFFECT_HEAL,                      //    10
	SPELL_EFFECT_BIND,                      //    11
	SPELL_EFFECT_PORTAL,                    //    12
	SPELL_EFFECT_RITUAL_BASE,               //    13
	SPELL_EFFECT_RITUAL_SPECIALIZE,         //    14
	SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL,    //    15
	SPELL_EFFECT_QUEST_COMPLETE,            //    16
	SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL,    //    17
	SPELL_EFFECT_RESURRECT,                 //    18
	SPELL_EFFECT_ADD_EXTRA_ATTACKS,         //    19
	SPELL_EFFECT_DODGE,                     //    20
	SPELL_EFFECT_EVADE,                     //    21
	SPELL_EFFECT_PARRY,                     //    22
	SPELL_EFFECT_BLOCK,                     //    23
	SPELL_EFFECT_CREATE_ITEM,               //    24
	SPELL_EFFECT_WEAPON,                    //    25
	SPELL_EFFECT_DEFENSE,                   //    26
	SPELL_EFFECT_PERSISTENT_AREA_AURA,      //    27
	SPELL_EFFECT_SUMMON,                    //    28
	SPELL_EFFECT_LEAP,                      //    29
	SPELL_EFFECT_ENERGIZE,                  //    30
	SPELL_EFFECT_WEAPON_PERCENT_DAMAGE,     //    31
	SPELL_EFFECT_TRIGGER_MISSILE,           //    32
	SPELL_EFFECT_OPEN_LOCK,                 //    33
	SPELL_EFFECT_TRANSFORM_ITEM,            //    34
	SPELL_EFFECT_APPLY_AREA_AURA,           //    35
	SPELL_EFFECT_LEARN_SPELL,               //    36
	SPELL_EFFECT_SPELL_DEFENSE,             //    37
	SPELL_EFFECT_DISPEL,                    //    38
	SPELL_EFFECT_LANGUAGE,                  //    39
	SPELL_EFFECT_DUAL_WIELD,                //    40
	SPELL_EFFECT_SUMMON_WILD,               //    41
//	SPELL_EFFECT_SUMMON_GUARDIAN,           //    42
	SPELL_EFFECT_JUMP_BEHIND_TARGET,        //    42
	SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER,//    43
	SPELL_EFFECT_SKILL_STEP,                //    44
	SPELL_EFFECT_ADD_HONOR,                 //    45
	SPELL_EFFECT_SPAWN,                     //    46
	SPELL_EFFECT_TRADE_SKILL,               //    47
	SPELL_EFFECT_STEALTH,                   //    48
	SPELL_EFFECT_DETECT,                    //    49
	SPELL_EFFECT_SUMMON_OBJECT,             //    50
	//SPELL_EFFECT_TRANS_DOOR,              //    50
	SPELL_EFFECT_FORCE_CRITICAL_HIT,        //    51
	SPELL_EFFECT_GUARANTEE_HIT,             //    52
	SPELL_EFFECT_ENCHANT_ITEM,              //    53
	SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY,    //    54
	SPELL_EFFECT_TAMECREATURE,              //    55
	SPELL_EFFECT_SUMMON_PET,                //    56
	SPELL_EFFECT_LEARN_PET_SPELL,           //    57
	SPELL_EFFECT_WEAPON_DAMAGE,             //    58
	SPELL_EFFECT_OPEN_LOCK_ITEM,            //    59
	SPELL_EFFECT_PROFICIENCY,               //    60
	SPELL_EFFECT_SEND_EVENT,                //    61
	SPELL_EFFECT_POWER_BURN,                //    62
	SPELL_EFFECT_THREAT,                    //    63
	SPELL_EFFECT_TRIGGER_SPELL,             //    64
	SPELL_EFFECT_APPLY_AREA_AURA2,          //    65
	SPELL_EFFECT_CREATE_MANA_GEM,           //    66
	SPELL_EFFECT_HEAL_MAX_HEALTH,           //    67
	SPELL_EFFECT_INTERRUPT_CAST,            //    68
	SPELL_EFFECT_DISTRACT,                  //    69
	SPELL_EFFECT_PULL,                      //    70
	SPELL_EFFECT_PICKPOCKET,                //    71
	SPELL_EFFECT_ADD_FARSIGHT,              //    72
	SPELL_EFFECT_UNTRAIN_TALENTS,           //    73
//	SPELL_EFFECT_SUMMON_TOTEM,              //    74
	SPELL_EFFECT_APPLY_GLYPH,               //    74
	SPELL_EFFECT_HEAL_MECHANICAL,           //    75
	SPELL_EFFECT_SUMMON_OBJECT_WILD,        //    76
	SPELL_EFFECT_SCRIPT_EFFECT,             //    77
	SPELL_EFFECT_ATTACK,                    //    78
	SPELL_EFFECT_SANCTUARY,                 //    79
	SPELL_EFFECT_ADD_COMBO_POINTS,          //    80
	SPELL_EFFECT_CREATE_HOUSE,              //    81
	SPELL_EFFECT_BIND_SIGHT,                //    82
	SPELL_EFFECT_DUEL,                      //    83
	SPELL_EFFECT_STUCK,                     //    84
	SPELL_EFFECT_SUMMON_PLAYER,             //    85
	SPELL_EFFECT_ACTIVATE_OBJECT,           //    86
    SPELL_EFFECT_WMO_DAMAGE,		        //    87
    SPELL_EFFECT_WMO_REPAIR,	            //    88
    SPELL_EFFECT_SUMMON3,	                //    89
    SPELL_EFFECT_SUMMON4,				    //    90
	SPELL_EFFECT_THREAT_ALL,                //    91
	SPELL_EFFECT_ENCHANT_HELD_ITEM,         //    92
	SPELL_EFFECT_SUMMON_PHANTASM,           //    93
	SPELL_EFFECT_SELF_RESURRECT,            //    94
	SPELL_EFFECT_SKINNING,                  //    95
	SPELL_EFFECT_CHARGE,                    //    96
	SPELL_EFFECT_SUMMON_CRITTER,            //    97
	SPELL_EFFECT_KNOCK_BACK,                //    98
	SPELL_EFFECT_DISENCHANT,                //    99
	SPELL_EFFECT_INEBRIATE,                 //    100
	SPELL_EFFECT_FEED_PET,                  //    101
	SPELL_EFFECT_DISMISS_PET,               //    102
	SPELL_EFFECT_REPUTATION,                //    103
	SPELL_EFFECT_SUMMON_OBJECT_SLOT1,       //    104
	SPELL_EFFECT_SUMMON_OBJECT_SLOT2,       //    105
	SPELL_EFFECT_SUMMON_OBJECT_SLOT3,       //    106
	SPELL_EFFECT_SUMMON_OBJECT_SLOT4,       //    107
	SPELL_EFFECT_DISPEL_MECHANIC,           //    108
	SPELL_EFFECT_SUMMON_DEAD_PET,           //    109
	SPELL_EFFECT_DESTROY_ALL_TOTEMS,        //    110
	SPELL_EFFECT_DURABILITY_DAMAGE,         //    111
	SPELL_EFFECT_SUMMON_DEMON,              //    112
	SPELL_EFFECT_RESURRECT_FLAT,            //    113
	SPELL_EFFECT_ATTACK_ME,                 //    114
	SPELL_EFFECT_DURABILITY_DAMAGE_PCT,     //    115
	SPELL_EFFECT_SKIN_PLAYER_CORPSE,        //    116
	SPELL_EFFECT_SPIRIT_HEAL,               //    117
	SPELL_EFFECT_SKILL,                     //    118
	SPELL_EFFECT_APPLY_PET_AURA,            //    119
	SPELL_EFFECT_TELEPORT_GRAVEYARD,        //    120
	SPELL_EFFECT_DUMMYMELEE,                //    121
	SPELL_EFFECT_UNKNOWN1,                  //    122
	SPELL_EFFECT_FILMING,                   //    123
	SPELL_EFFECT_PLAYER_PULL,               //    124
	SPELL_EFFECT_REDUCE_THREAT_PERCENT,     //    125
	SPELL_EFFECT_UNKNOWN5,                  //    126
	SPELL_EFFECT_PROSPECTING,               //    127
	SPELL_EFFECT_UNKNOWN7,                  //    128
	SPELL_EFFECT_UNKNOWN9,                  //    129
	SPELL_EFFECT_UNKNOWN10,                 //    130
	SPELL_EFFECT_UNKNOWN11,                 //    131
	SPELL_EFFECT_UNKNOWN12,                 //    132
	SPELL_EFFECT_FORGET_SPECIALIZATION,     //    133
	SPELL_EFFECT_KILL_CREDIT,               //    134
	SPELL_EFFECT_UNKNOWN15,                 //    135
	SPELL_EFFECT_HEAL_MAXHEALTH_PCT,        //    136
	SPELL_EFFECT_ENERGIZE_MAXPOWER_PCT,     //    137
	SPELL_EFFECT_KNOCK_BACK2,               //    138
	SPELL_EFFECT_UNKNOWN19,                 //    139
	SPELL_EFFECT_FORCE_CAST,                //    140
	SPELL_EFFECT_UNKNOWN21,                 //    141
	SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE,  //    142
	SPELL_EFFECT_UNKNOWN22,                 //    143
	SPELL_EFFECT_KNOCK_BACK3,               //    144
	SPELL_EFFECT_UNKNOWN24,                 //    145
	SPELL_EFFECT_RUNE_ACTIVATE,             //    146
	SPELL_EFFECT_QUEST_FAIL,                //    147
	SPELL_EFFECT_UNKNOWN26,                 //    148
	SPELL_EFFECT_CHARGE2,			        //    149
	SPELL_EFFECT_UNKNOWN28,                 //    150
	SPELL_EFFECT_SUMMON_TARGET,             //    151
	SPELL_EFFECT_UNKNOWN29,                 //    152
	SPELL_EFFECT_TAME_CREATURE,             //    153
	SPELL_EFFECT_UNKNOWN30,                 //    154
	SPELL_EFFECT_UNKNOWN31,                 //    155
	SPELL_EFFECT_ADD_SOCKET,                //    156
	SPELL_EFFECT_UNKNOWN33,                 //    157
	SPELL_EFFECT_CREATE_ITEM_2,             //    158
	SPELL_EFFECT_MILLING,					//    158
	SPELL_EFFECT_ALLOW_RENAME_PET,          //    159
	SPELL_EFFECT_UNKNOWN40,                 //    160
	SPELL_EFFECT_SET_TALENT_SPECS_COUNT,    //    161
	SPELL_EFFECT_ACTIVATE_TALENT_SPEC,      //    162
	TOTAL_SPELL_EFFECTS,                    //    160
};

enum SpellEnchantmentTypes
{
	SPELL_ENCHANT_TYPE_TRIGGER_SPELL_ON_MELEE_HIT		= 1,
	SPELL_ENCHANT_TYPE_MOD_DMG							= 2,
	SPELL_ENCHANT_TYPE_CAST_SPELL						= 3,
	SPELL_ENCHANT_TYPE_MOD_RESIST						= 4,
	SPELL_ENCHANT_TYPE_MOD_ITEM_LIKE_STAT				= 5,	//not just rating, it is simply item_mods values, can be stamina and others
	SPELL_ENCHANT_TYPE_MOD_DPS							= 6,
	SPELL_ENCHANT_TYPE_ADD_SPELL						= 7,
	SPELL_ENCHANT_TYPE_ADD_SOCKET						= 8,
	SPELL_ENCHANT_TYPE_CUSTOM_PROC_ANY_DMG_DONE			= 19,
	SPELL_ENCHANT_TYPE_CUSTOM_PROC_ANY_DMG_TAKEN		= 20,
	SPELL_ENCHANT_TYPE_CUSTOM_MOD_ITEM_STAT				= 21,
};

// target type flags
enum SpellTargetTypes
{
    SPELL_TARGET_TYPE_NONE              = 0x01,
    SPELL_TARGET_TYPE_PROFESSION        = 0x02,
    SPELL_TARGET_TYPE_NONE1             = 0x04,
    SPELL_TARGET_TYPE_NONE2             = 0x08,
    SPELL_TARGET_TYPE_ENCHANTABLE_ITEM  = 0x10,
    SPELL_TARGET_TYPE_UNK               = 0x20,     // seems to be scripted stuff
    SPELL_TARGET_TYPE_UNK0              = 0x40,     // lots of spells interesting to research this one further
    SPELL_TARGET_TYPE_UNK1              = 0x80,     // something todo with scripted and GM stuff
    SPELL_TARGET_TYPE_UNK2              = 0x100,    // lots of spells interesting to research this one further...
    SPELL_TARGET_TYPE_PLAYER_CORPSE     = 0x200,
    SPELL_TARGET_TYPE_DEATHx            = 0x400,
    SPELL_TARGET_TYPE_NONE3             = 0x800,
    SPELL_TARGET_TYPE_NONE4             = 0x1000,
    SPELL_TARGET_TYPE_NONE5             = 0x2000,
    SPELL_TARGET_TYPE_GAME_OBJECTS      = 0x4000, // like chests and mining
    SPELL_TARGET_TYPE_DEATH             = 0x8000,
};

enum SpellTypes // SPELL_ENTRY_buffType
{
    SPELL_TYPE_NONE                 = 0x00000000,
    SPELL_TYPE_SEAL                 = 0x00000001,
    SPELL_TYPE_ASPECT               = 0x00000002,
    SPELL_TYPE_BLESSING             = 0x00000004,
    SPELL_TYPE_CURSE                = 0x00000008,
    SPELL_TYPE_STING                = 0x00000010,
    SPELL_TYPE_ARMOR                = 0x00000020,
    SPELL_TYPE_AURA                 = 0x00000040,
    //hmm these could be named simply incompatible spells. One active at a time
    SPELL_TYPE_INNER_FIRE_WILL      = 0x00000080,
//    SPELL_TYPE_TRACK                = 0x00000100,
    SPELL_TYPE_HUNTER_TRAP          = 0x00000200,
    SPELL_TYPE_MAGE_INTEL           = 0x00000400,
    SPELL_TYPE_MAGE_MAGI            = 0x00000800,
    SPELL_TYPE_MAGE_WARDS           = 0x00001000,
    SPELL_TYPE_PRIEST_SH_PPROT      = 0x00002000,
    SPELL_TYPE_SHIELD               = 0x00004000,
    SPELL_TYPE_FORTITUDE            = 0x00008000,
    SPELL_TYPE_WARLOCK_IMMOLATE     = 0x00010000,
    SPELL_TYPE_MAGE_AMPL_DUMP       = 0x00020000,
    SPELL_TYPE_WARLOCK_BANE		    = 0x00040000, 
    SPELL_TYPE_ELIXIR_BATTLE		= 0x00080000, 
    SPELL_TYPE_ELIXIR_GUARDIAN      = 0x00100000, 
    SPELL_TYPE_ELIXIR_FLASK         = SPELL_TYPE_ELIXIR_BATTLE | SPELL_TYPE_ELIXIR_GUARDIAN, //weee, this contains both battle and guardian elixirs ;)
    SPELL_TYPE_HUNTER_MARK			= 0x00200000,
    SPELL_TYPE_WARRIOR_SHOUT        = 0x00400000,
	SPELL_TYPE_QUIVER_HASTE			= 0x00800000,
	SPELL_TYPE_CORRUPTION			= 0x01000000,
	SPELL_TYPE_PRESENCE				= 0x02000000,
	SPELL_TYPE_POISON				= 0x04000000,
	SPELL_TYPE_WINDFURRY			= 0x08000000,
	SPELL_TYPE_SHOCK				= 0x10000000,
	SPELL_TYPE_FLAMETONGUE			= 0x20000000,
	SPELL_TYPE_SUNFIRE_MOONFIRE		= 0x40000000,
	SPELL_TYPE_CHACKRA				= 0x80000000,
};

//custom stuff generated for spells that will not change in time
enum SpellIsFlags
{
    SPELL_FLAG_IS_DAMAGING					= 0x00000001,
    SPELL_FLAG_IS_HEALING					= 0x00000002,
    SPELL_FLAG_IS_TARGETINGSTEALTHED		= 0x00000004,
    SPELL_FLAG_IS_REQUIRECOOLDOWNUPDATE		= 0x00000008, //it started with rogue cold blood but i'm sure others will come
    SPELL_FLAG_IS_POISON					= 0x00000010, //rogue has a few spells that can stack so can't use the spell_type enum ;)
    SPELL_FLAG_IS_FINISHING_MOVE			= 0x00000020, //rogue has a few spells that can stack so can't use the spell_type enum ;)
    SPELL_FLAG_IS_AA_TARGETTING_FRIENDLY	= 0x00000040, //there's got to be a better way for this. Right now i have no idea what that is 
    SPELL_FLAG_IS_CHILD_SPELL				= 0x00000080, //auras proc auras that have same name, these should not remove mother aura when adding to target
    SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET		= 0x00000100, //we should cast these on pet too
    SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER	= 0x00000200, //we should cast these on owner too
    SPELL_FLAG_IS_EXPIREING_WITH_PET				= 0x00000400, //when pet dies, we remove this too
    SPELL_FLAG_IS_CASTED_BY_PET_SUMMON_ON_PET		= 0x00000800, //when pet is summoned
	SPELL_FLAG_IS_FORCEDDEBUFF				= 0x00001000, // forced to be a debuff
	SPELL_FLAG_IS_FORCEDBUFF				= 0x00002000, // forced to be a buff
	SPELL_FLAG_IS_INHERITING_LEVEL			= 0x00004000, // summons to inherit caster level or not
	SPELL_FLAG_IS_REQUIRING_SM_MOD			= 0x00008000, // 
	SPELL_FLAG_IS_HEAL_OVER_TIME			= 0x00010000, // 
	SPELL_FLAG_IS_BUFF						= 0x00020000, // used for ai_agents to check if we need to see if target already has the spell
	SPELL_FLAG_IS_REQ_ITEM_CASTER_MOD_CHK	= 0x00040000, // mixology boosts flask and elixir spells
	SPELL_FLAG_IS_FLASK_OR_ELIXIR			= 0x00080000, // mixology boosts flask and elixir spells
	SPELL_FLAG_IS_ALCHEMIST_STONE_TARGET	= 0x00100000, // mixology boosts flask and elixir spells
	SPELL_FLAG_IS_CHILL_SPELL				= 0x00200000, // frost and decreasing stuff
	SPELL_FLAG_IS_PROC_TRIGGER_PROC			= 0x00400000, // some spells trigger proc handling
	SPELL_FLAG_IS_ALLOW_MAGNET_TARGET		= 0x00800000, // ex charm spells cannot get redirected
	SPELL_FLAG_IS_SUMMONING_AT_TARGET		= 0x01000000, // ex hunter freezing arrow
	SPELL_FLAG_IS_DISABLED					= 0x02000000, // we are able to disable spells via DB
	SPELL_FLAG_IS_TRIGGERED_BY_TARGET		= 0x04000000, // force target to cast a spell
	SPELL_FLAG_IS_DMGSPLIT_TARGET_CASTER	= 0x08000000, // if target attacked then split with caster
	SPELL_FLAG_IS_DMGSPLIT_CASTER_TARGET	= 0x10000000, // if caster attacked then split with target -> can have 1 atm !
	SPELL_FLAG_IS_NOT_SAVED_ON_LOGOUT		= 0x20000000, 
	SPELL_FLAG_IS_CONDITIONAL_PASSIVE_CAST	= 0x40000000, // some talents are active only if health is below x%
	SPELL_FLAG_IS_STACKABLE_OTHER_CASTER_POS= 0x80000000, // almost not profession spell procs other spells
};

enum SpellIsFlags2
{
	SPELL_FLAG2_IS_BREAKING_STEALTH				= 0x00000001,	//manually set these for those that QQ
	SPELL_FLAG2_IS_VALUE_SCALED					= 0x00000002,	//when spell value is too small to store in int
	SPELL_FLAG2_IS_VALUE_OVER_TIME				= 0x00000004,	//sometimes values should be used / tickcount 
	SPELL_FLAG2_IS_DRAINING_ALL_POWER			= 0x00000008,	//the new spells that drain all additional power. Need to find the spell flag for this. There must be one 
	SPELL_FLAG2_IS_AVOIDING_ALL_RESIST			= 0x00000010,	//only chaos bolt ?
	SPELL_FLAG2_IS_GUILD_PERK					= 0x00000020,	//i bet this has a skilline or something
	SPELL_FLAG2_IS_CASTABLE_BY_ANYONE			= 0x00000040,	//archaeology for example
	SPELL_FLAG2_IS_TRIGGERED_ON_TARGET			= 0x00000080,   // force on target cast a spell
	SPELL_FLAG2_IS_ENEMY_AOE_TARGETTING			= 0x00000100,   // one of the effects of this spell will target more then 1 person
	SPELL_FLAG2_IS_MOVEMENT_IMPAIRING_SPELL		= 0x00000200,   // 
	SPELL_FLAG2_IS_TAXI_CASTABLE_ONLY			= 0x00000400,   // 
	SPELL_FLAG2_IS_PROFESSION_SPELL				= 0x00000800,   // in case i did not miss out any here :P
	SPELL_FLAG2_IS_ALLOWED_TO_LEAVE_CHAINED_AURAS = 0x00001000,	//1 spell only ?
//	SPELL_FLAG2_IS_TALENT_SPEC					= 0x00002000,	// the icons you click client side
	SPELL_FLAG2_IS_NON_CLIENT_CASTABLE			= 0x00004000,	// there should be a lot of spells like this. Right now only hack spells added manually
	SPELL_FLAG2_IS_PROCCING_PURSUIT_OF_JUSTICE	= 0x00008000,	// what a waste of a flag, i hope thsi talent gets removed :P
	SPELL_FLAG2_IS_REFLECTABLE					= 0x00010000,	// copy pasting old crap code
	SPELL_FLAG2_IS_NON_REFLECTABLE				= 0x00020000,	// copy pasting old crap code
	SPELL_FLAG2_IS_CASTABLE_FEARED_CHARM_SLEEP	= 0x00040000,	//
	SPELL_FLAG2_IS_CASTABLE_STUNNED				= 0x00080000,	//
	SPELL_FLAG2_IS_CASTABLE_PACIFIED			= 0x00100000,	// pacify is for phisical dmg
	SPELL_FLAG2_IS_CASTABLE_SILANCED			= 0x00200000,	//
	SPELL_FLAG2_IS_CASTABLE_SCHOOL_SILANCE		= 0x00400000,	//
    SPELL_FLAG2_IS_AA_CALLING_SCRIPT			= 0x00800000,	//there is one spell that requires both the visual effects of Dyn Object and the periodic cast of a spell
    SPELL_FLAG2_IS_IGNORING_MOVE_INTERUPT		= 0x01000000,	//
    SPELL_FLAG2_IS_MAP_CAST_BOUND				= 0x02000000,	// auras that link 2 objects, like Dark Intent, beacon of light,...
    SPELL_FLAG2_IS_OK_TO_NO_RESET				= 0x04000000,	// on player spell reset, these spells can be kept as safe spells. Ex : profession spells = racials
    SPELL_FLAG2_IS_TICKING_IMEDIATLY			= 0x08000000,	// spells like Rend tick instantly after getting applied
    SPELL_FLAG2_IS_SPELL_STEAL_SAFE				= 0x10000000,	// manually enabled talents that can be spell stealed
    SPELL_FLAG2_IS_CONVERTING_RECHARGING_RUNE	= 0x20000000,	// some DH spells willtarget full runes, others the runes that got recently used
    SPELL_FLAG2_IS_ENERGIZING					= 0x40000000,	// restore energy. Used by target raid members
    SPELL_FLAG2_IS_AA_TARGETTING_EVERYONE		= 0x80000000,	// neutral caster
};

enum SpellIsFlags3
{
	SPELL_FLAG3_IS_BLOCKING_BLINK				= 0x00000001,	// I'm sure there is a better way to detect this. Kinda rage fixing it for the moment
	SPELL_FLAG3_IS_DIRECT_TARGET				= 0x00000002,	// required for proc : Direct heal or direct dmg spell means it has single target ( not AOE )
	SPELL_FLAG3_IS_FRIENDLY_AOE_TARGETING		= 0x00000004,	// required for proc : Direct heal or direct dmg spell means it has single target ( not AOE )
	SPELL_FLAG3_IS_STEALTH_SPELL				= 0x00000008,	// for faery fire cast condition
	SPELL_FLAG3_IS_ALLOWED_0_COOLDOWN			= 0x00000010,	// required for chain lightning and Elemental Fury specialization
	SPELL_FLAG3_IS_PROPERLY_IMPLEMENTED_CANCEL	= 0x00000020,	// for example Glyph of Unleashed Lightning & Lightning bolt
	SPELL_FLAG3_IS_NOT_USING_HASTE				= 0x00000040,	// mounts / professions...
	SPELL_FLAG3_IS_NOT_CASTABLE_ROOTED			= 0x00000080,	// charge, intercept...
	SPELL_FLAG3_IS_SAFE_SIMULACRUM_STEAL		= 0x00000100,	// almost all mana spells. just almost
	SPELL_FLAG3_IS_HUNTER_TRAP					= 0x00000200,	// using it to detect dyn go trap arm duration
	SPELL_FLAG3_IS_BREAKING_STEALTH_TARGET		= 0x00000400,	// 
	SPELL_FLAG3_IS_REMOVED_ON_SHAPESHIFT		= 0x00000800,	// 
	SPELL_FLAG3_IS_OVERRIDE_ON_TARGET			= 0x00001000,	// caster can put override on target and it will be called
	SPELL_FLAG3_IS_SCHOOL_IMMUNE_ALL			= 0x00002000,	// cyclone denies both heal and debuffs
	SPELL_FLAG3_IS_DISPEL_MECHANIC				= 0x00004000,	// 
	SPELL_FLAG3_IS_DISABLE_OTHER_SPELL_CPROC	= 0x00008000,	// almost not profession spell procs other spells
	SPELL_FLAG3_IS_SKIP_REFRESH_SAME_AURAS_OTHERS	= 0x00010000,	// 
	SPELL_FLAG3_IS_NEEDING_LOS_CHECK			= 0x00020000,	// 
	SPELL_FLAG3_IS_SKIPPING_AUTOFACE_ON_CAST	= 0x00040000,	// 
};

#define Need_SM_Apply(x) (x->c_is_flags & SPELL_FLAG_IS_REQUIRING_SM_MOD )
/*
enum SpellCoefficientsFlags
{
	SPELL_FLAG_IS_DOT_SPELL				= 0x00000001, //Damage over Time or Healing over Time Spells
	SPELL_FLAG_IS_HOT_SPELL				= 0x00000002, //Damage over Time or Healing over Time Spells
	SPELL_FLAG_IS_DD_SPELL				= 0x00000004, //Direct Damage or Direct Healing Spells
	SPELL_FLAG_IS_DH_SPELL				= 0x00000008, //Direct Damage or Direct Healing Spells
	SPELL_FLAG_IS_DD_DH_DOT_SPELL		= SPELL_FLAG_IS_DOT_SPELL | SPELL_FLAG_IS_HOT_SPELL | SPELL_FLAG_IS_DD_SPELL | SPELL_FLAG_IS_DH_SPELL, //DoT+(DD|DH) Spells
	SPELL_FLAG_AOE_SPELL				= 0x00000010, //AoE Spells
	SPELL_FLAG_ADITIONAL_EFFECT			= 0x00000020, //Spells with aditional effect not DD or DoT or HoT
}; */

//max value can be 15 !!!!
enum DiminishingGroup
{
	DIMINISHING_GROUP_STUN				= 0,
	DIMINISHING_GROUP_STUN_PROC			= 1,
	DIMINISHING_GROUP_ROOT				= 2,
	DIMINISHING_GROUP_ROOT_PROC			= 3,
	DIMINISHING_GROUP_SLEEP				= 4,
	DIMINISHING_GROUP_BLIND_CYCLONE		= 5,
	DIMINISHING_GROUP_GOUGE_POLY_SAP	= 6,	//disorient effects
	DIMINISHING_GROUP_FEAR				= 7,
	DIMINISHING_GROUP_CHARM				= 8,
	DIMINISHING_GROUP_KIDNEY_SHOT		= 9,
	DIMINISHING_GROUP_HORROR			= 10,
	DIMINISHING_GROUP_BANISH			= 11,
	DIMINISHING_GROUP_FIX_DIMINISHED	= 12,
	DIMINISHING_GROUP_DISARM			= 13,
	DIMINISHING_GROUP_SILENCE			= 14,
	DIMINISHING_GROUP_SLOW				= 15,	//not sure there is one like this
	DIMINISHING_GROUP_DISORIENT			= 16,	
	DIMINISHING_GROUP_MISS				= 17,	//all together because we are using stacking chances
	DIMINISHING_GROUP_DODGE				= 18,	//all together because we are using stacking chances
	DIMINISHING_GROUP_PARRY				= 19,	//all together because we are using stacking chances
	DIMINISHING_GROUP_MAX_PVP_DUR		= 20,	//only diminish once
//	DIMINISHCOUNT								//!!!this is defined in unit.h !!!
};

bool CanAgroHash(uint32 spellhashname);

ARCEMU_INLINE bool IsSpellDisabled(SpellEntry *sp)
{
	if( sp->c_is_flags & SPELL_FLAG_IS_DISABLED )
		return true;
	return false;
}

/************************************************************************/
/* IsDamagingSpell, this function seems slow, its only used rarely      */
/************************************************************************/
ARCEMU_INLINE bool IsDamagingSpell(SpellEntry *sp, uint32 ind)
{
//    switch (sp->Effect[ind])
	switch( sp->eff[ind].Effect )
    {
        case SPELL_EFFECT_SCHOOL_DAMAGE:
        case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
        case SPELL_EFFECT_ADD_EXTRA_ATTACKS:
        case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
        case SPELL_EFFECT_POWER_BURN:
        case SPELL_EFFECT_ATTACK:
		case SPELL_EFFECT_DUMMYMELEE:
            return true;
		case SPELL_EFFECT_APPLY_AURA:
		case SPELL_EFFECT_APPLY_AREA_AURA:
		case SPELL_EFFECT_APPLY_AREA_AURA2:
			{
//				switch (sp->EffectApplyAuraName[ind])
				switch (sp->eff[ind].EffectApplyAuraName)
				{
					case 3://SPELL_AURA_PERIODIC_DAMAGE:
					case 43://SPELL_AURA_PROC_TRIGGER_DAMAGE:
					case 53://SPELL_AURA_PERIODIC_LEECH:
					case 89://SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
					case 162://SPELL_AURA_POWER_BURN:
						return true;
				}
			}break;
    }
    return false;
}

ARCEMU_INLINE bool IsDirectDamagingSpell(SpellEntry *sp, uint32 ind)
{
	switch( sp->eff[ind].Effect )
    {
        case SPELL_EFFECT_SCHOOL_DAMAGE:
        case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
        case SPELL_EFFECT_ADD_EXTRA_ATTACKS:
        case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
        case SPELL_EFFECT_POWER_BURN:
        case SPELL_EFFECT_ATTACK:
		case SPELL_EFFECT_DUMMYMELEE:
            return true;
    }
    return false;
}

ARCEMU_INLINE bool IsDamagingSpell(SpellEntry *sp)
{
	if( IsDamagingSpell(sp,0) )
		return true;
	if( IsDamagingSpell(sp,1) )
		return true;
	if( IsDamagingSpell(sp,2) )
		return true;
    return false;
}

ARCEMU_INLINE uint32 IsHealingEffect(SpellEntry *sp,int32 i)
{
//    switch( sp->eff[i].Effect )
    switch( sp->eff[i].Effect )
    {
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_HEAL:
//        case SPELL_EFFECT_HEALTH_FUNNEL:
        case SPELL_EFFECT_HEAL_MAX_HEALTH:
            return 1;
		case SPELL_EFFECT_APPLY_AURA:
		case SPELL_EFFECT_APPLY_AREA_AURA:
		case SPELL_EFFECT_APPLY_AREA_AURA2:
			{
//				switch (sp->EffectApplyAuraName[ind])
				switch (sp->eff[i].EffectApplyAuraName)
				{
		            case 8://SPELL_AURA_PERIODIC_HEAL:
				    case 62://SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
						return 1;
				}
			}break;
		default: break;
    }
	return 0;
}


ARCEMU_INLINE uint32 IsEnergizingEffect(SpellEntry *sp,int32 i)
{
//    switch( sp->eff[i].Effect )
    switch( sp->eff[i].Effect )
    {
		case SPELL_EFFECT_ENERGIZE:
		case SPELL_EFFECT_ENERGIZE_MAXPOWER_PCT:
        case SPELL_EFFECT_POWER_DRAIN:
//		case SPELL_EFFECT_POWER_FUNNEL:
            return 1;
		case SPELL_EFFECT_APPLY_AURA:
		case SPELL_EFFECT_APPLY_AREA_AURA:
		case SPELL_EFFECT_APPLY_AREA_AURA2:
			{
//				switch (sp->EffectApplyAuraName[ind])
				switch (sp->eff[i].EffectApplyAuraName)
				{
					case 21://SPELL_AURA_MOD_TOTAL_MANA_REGEN_PCT
		            case 24://SPELL_AURA_PERIODIC_ENERGIZE
				    case 226://SPELL_AURA_DRINK_NEW:
						return 1;
				}
			}break;
		default: break;
    }
	return 0;
}


uint32 IsHealingSpell(SpellEntry *sp);
uint32 IsEnergizingSpell(SpellEntry *sp);

ARCEMU_INLINE bool IsInrange(float x1,float y1, float z1,float x2,float y2, float z2,float square_r)
{
    float t;
    float r;
    t=x1-x2;
    r=t*t;
    t=y1-y2;
    r+=t*t;
    t=z1-z2;
    r+=t*t;
    return ( r<=square_r);
}

bool IsInrange(LocationVector & location, Object * o, float square_r);
bool IsInrange(float x1,float y1, float z1, Object * o,float square_r);
bool IsInrange(float x1,float y1, Object * o,float square_r);
bool TargetTypeCheck(Object *obj,uint32 ReqCreatureTypeMask);

//bool IsInrange(Object * o1,Object * o2,float square_r);
ARCEMU_INLINE bool IsInrange(Object * o1,Object * o2,float square_r)
{
    return IsInrange(o1->GetPositionX(),o1->GetPositionY(),o1->GetPositionZ(),
        o2->GetPositionX(),o2->GetPositionY(),o2->GetPositionZ(),square_r);
}

class SpellCastTargets
{
public:
    void read ( WorldPacket & data,uint64 caster );
    void write ( StackWorldPacket & data);

    SpellCastTargets() : m_targetMask(0), m_targetMaskExtended(0), m_unitTarget(0), m_itemTarget(0), m_srcX(0), m_srcY(0), m_srcZ(0),
        m_destX(0), m_destY(0), m_destZ(0) {}

    SpellCastTargets(uint16 TargetMask, uint64 unitTarget, uint64 itemTarget, float srcX, float srcY,
        float srcZ, float destX, float destY, float destZ) : m_targetMask(TargetMask), m_targetMaskExtended(0), m_unitTarget(unitTarget),
        m_itemTarget(itemTarget), m_srcX(srcX), m_srcY(srcY), m_srcZ(srcZ), m_destX(destX), m_destY(destY), m_destZ(destZ) {}

    SpellCastTargets(uint64 unitTarget) : m_targetMask(0x2), m_targetMaskExtended(0), m_unitTarget(unitTarget), m_itemTarget(0),
        m_srcX(0), m_srcY(0), m_srcZ(0), m_destX(0), m_destY(0), m_destZ(0) {}

    SpellCastTargets(WorldPacket & data, uint64 caster) : m_targetMask(0), m_targetMaskExtended(0), m_unitTarget(0), m_itemTarget(0), m_srcX(0), m_srcY(0), m_srcZ(0),
        m_destX(0), m_destY(0), m_destZ(0)
    {
        read(data, caster);
    }

    SpellCastTargets& operator=(const SpellCastTargets &target)
    {
        m_unitTarget = target.m_unitTarget;
        m_itemTarget = target.m_itemTarget;

        m_srcX = target.m_srcX;
        m_srcY = target.m_srcY;
        m_srcZ = target.m_srcZ;

        m_destX = target.m_destX;
        m_destY = target.m_destY;
        m_destZ = target.m_destZ;

        m_strTarget = target.m_strTarget;

        m_targetMask = target.m_targetMask;
		m_targetMaskExtended = target.m_targetMaskExtended;

		m_missileFlags = target.m_missileFlags;
		missilepitch = target.missilepitch;
		missilespeed = target.missilespeed;
		missileunkcheck = target.missileunkcheck;
		unkdoodah = target.unkdoodah;
		unkdoodah2 = target.unkdoodah2;
		traveltime = target.traveltime;
        return *this;
    }

	uint8  m_missileFlags;
    uint16 m_targetMask;
    uint16 m_targetMaskExtended;			// this could be a 32 also
	uint8 m_unk302;
    uint64 m_unitTarget;
    uint64 m_itemTarget;
    float m_srcX, m_srcY, m_srcZ;
    float m_destX, m_destY, m_destZ;
    std::string m_strTarget;
	WoWGuid guid;
	float missilepitch, missilespeed;
	uint8 missileunkcheck;
	uint32 unkdoodah, unkdoodah2;
	float traveltime;
};

enum SpellState
{
    SPELL_STATE_NULL      = 0,
    SPELL_STATE_PREPARING = 1,
    SPELL_STATE_CASTING   = 2,
    SPELL_STATE_FINISHED  = 3,
    SPELL_STATE_IDLE      = 4
};

enum DISPEL_TYPE
{
    DISPEL_NULL				= 0,
    DISPEL_MAGIC			= 1,
    DISPEL_CURSE			= 2,
    DISPEL_DISEASE			= 3,
    DISPEL_POISON			= 4,
	DISPEL_COUNT_NON_BENEFICIAL, 
    DISPEL_STEALTH			= 5,
    DISPEL_INVISIBILTY		= 6,
    DISPEL_ALL				= 7,
    DISPEL_SPECIAL_NPCONLY	= 8,
    DISPEL_ENRAGE			= 9,
    DISPEL_ZGTRINKETS		= 10,
	DISPEL_COUNT
};

enum MECHANICS
{
    MECHANIC_CHARMED = 1,
    MECHANIC_DISORIENTED, // 2
    MECHANIC_DISARMED, // 3
    MECHANIC_DISTRACED, // 4
    MECHANIC_FLEEING, // 5
    MECHANIC_GRIPPED, // 6
    MECHANIC_ROOTED, // 7
    MECHANIC_SLOWED, // 8
    MECHANIC_SILENCED, // 9
    MECHANIC_ASLEEP, // 10
    MECHANIC_ENSNARED, // 11
	MECHANIC_STUNNED, // 12
	MECHANIC_FROZEN, // 13
	MECHANIC_INCAPACIPATED, // 14
	MECHANIC_BLEEDING, // 15
	MECHANIC_HEALING, // 16
	MECHANIC_POLYMORPHED, // 17
	MECHANIC_BANISHED, // 18
	MECHANIC_SHIELDED, // 19
	MECHANIC_SHACKLED, // 20
	MECHANIC_MOUNTED, // 21
	MECHANIC_INFECTED, // 22
	MECHANIC_TURNED, // 23 same as fear, but specially made for spell "Turn Evil"
	MECHANIC_HORRIFIED, // 24
	MECHANIC_INVULNERABLE_FORBID, // 25
	MECHANIC_INTERRUPTED, // 26
	MECHANIC_DAZED, // 27
	MECHANIC_DISCOVERY, // 28
	MECHANIC_INVULNERABLE, // 29
	MECHANIC_SAPPED, // 30
	MECHANIC_ENRAGED, // 31
//	MECHANIC_TOTAL, // !!! this is defined again in unit.h !!!
};

//#define MECHANIC_MOVEMENT_IMPARRING_FLAGS ( ( 1<<MECHANIC_CHARMED ) | (1<<MECHANIC_DISORIENTED) | (1<<MECHANIC_DISTRACED) | (1<<MECHANIC_FLEEING) | (1<<MECHANIC_ROOTED) | (1<<MECHANIC_SLOWED) | (1<<MECHANIC_ASLEEP)| (1<<MECHANIC_ENSNARED) | (1<<MECHANIC_HORRIFIED) | (1<<MECHANIC_DAZED) )

typedef enum {
   EFF_TARGET_NONE										= 0,	//this is not "none" targeting. It means client is not sending a target and that server should guess one. Ex glyphs
   EFF_TARGET_SELF										= 1,
   EFF_TARGET_INVISIBLE_OR_HIDDEN_ENEMIES_AT_LOCATION_RADIUS		= 3,
   EFF_TARGET_PET										= 5,
   EFF_TARGET_SINGLE_ENEMY								= 6,
   EFF_TARGET_SCRIPTED_TARGET							= 7,
   EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS  = 8,
   EFF_TARGET_HEARTSTONE_LOCATION						= 9,
   EFF_TARGET_ALL_ENEMY_IN_AREA							= 15,
   EFF_TARGET_ALL_ENEMY_IN_AREA_INSTANT					= 16,
   EFF_TARGET_TELEPORT_LOCATION							= 17,
   EFF_TARGET_LOCATION_TO_SUMMON						= 18,
   EFF_TARGET_ALL_PARTY_AROUND_CASTER					= 20,
   EFF_TARGET_SINGLE_FRIEND								= 21,
   EFF_TARGET_ALL_ENEMIES_AROUND_CASTER					= 22,	//this is combined with something else meaning other then simply enemoes
   EFF_TARGET_GAMEOBJECT								= 23,
   EFF_TARGET_IN_FRONT_OF_CASTER						= 24,
   EFF_TARGET_DUEL										= 25,//Dont know the real name!!!
   EFF_TARGET_GAMEOBJECT_ITEM							= 26,
   EFF_TARGET_PET_MASTER								= 27,
   EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED				= 28,
   EFF_TARGET_ALL_ENEMY_AT_ENEMY_IN_AREA_CHANNELED		= 29,
   EFF_TARGET_ALL_FRIENDLY_IN_AREA						= 30,
   EFF_TARGET_ALL_SCRIPTED_OR_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME	= 31,
   EFF_TARGET_MINION									= 32,
   EFF_TARGET_ALL_PARTY_IN_AREA							= 33,
   EFF_TARGET_SINGLE_PARTY								= 35,
   EFF_TARGET_PET_SUMMON_LOCATION						= 36,
   EFF_TARGET_ALL_PARTY									= 37,
   EFF_TARGET_SCRIPTED_OR_SINGLE_TARGET					= 38,
   EFF_TARGET_SELF_FISHING								= 39,
   EFF_TARGET_SCRIPTED_GAMEOBJECT						= 40,
   EFF_TARGET_TOTEM_EARTH								= 41,
   EFF_TARGET_TOTEM_WATER								= 42,
   EFF_TARGET_TOTEM_AIR									= 43,
   EFF_TARGET_TOTEM_FIRE								= 44,
   EFF_TARGET_CHAIN										= 45,
   EFF_TARGET_SCIPTED_OBJECT_LOCATION					= 46,
   EFF_TARGET_DYNAMIC_OBJECT							= 47,//not sure exactly where is used
   EFF_TARGET_MULTIPLE_SUMMON_LOCATION					= 48,
   EFF_TARGET_MULTIPLE_SUMMON_PET_LOCATION				= 49,
   EFF_TARGET_SUMMON_LOCATION							= 50,
   EFF_TARGET_CALIRI_EGS								= 51,
   EFF_TARGET_LOCATION_NEAR_CASTER						= 52,
   EFF_TARGET_CURRENT_SELECTION							= 53,
   EFF_TARGET_TARGET_AT_ORIENTATION_TO_CASTER			= 54,
   EFF_TARGET_LOCATION_INFRONT_CASTER					= 55,
   EFF_TARGET_ALL_RAID									= 56,
   EFF_TARGET_PARTY_MEMBER								= 57,
   EFF_TARGET_TARGET_FOR_VISUAL_EFFECT					= 59,
   EFF_TARGET_SCRIPTED_TARGET2							= 60,
   EFF_TARGET_AREAEFFECT_PARTY_AND_CLASS				= 61,
   EFF_TARGET_PRIEST_CHAMPION							= 62, //wtf ?
   EFF_TARGET_NATURE_SUMMON_LOCATION					= 63, 
   EFF_TARGET_BEHIND_TARGET_LOCATION					= 65, 
   EFF_TARGET_MULTIPLE_GUARDIAN_SUMMON_LOCATION			= 72,
   EFF_TARGET_NETHETDRAKE_SUMMON_LOCATION				= 73,
   EFF_TARGET_SCRIPTED_LOCATION							= 74,
   EFF_TARGET_LOCATION_INFRONT_CASTER_AT_RANGE			= 75,
   EFF_TARGET_ENEMYS_IN_ARE_CHANNELED_WITH_EXCEPTIONS	= 76,
   EFF_TARGET_SELECTED_ENEMY_CHANNELED					= 77,
   EFF_TARGET_SELECTED_ENEMY_DEADLY_POISON				= 86,
   EFF_TARGET_SELECTION_LOCATION						= 87,	//seems to be for everything 
	//these are custom, feel free to move them further if tageting gets extended
   EFF_TARGET_CUSTOM_RAID_INRANGE						= 98,
   EFF_TARGET_CUSTOM_PARTY_INJURED_SINGLE				= 99,
   EFF_TARGET_CUSTOM_PARTY_INJURED_MULTI				= 100,
   EFF_TARGET_CUSTOM_RAID_INJURED_MULTI					= 101,
   EFF_TARGET_CUSTOM_RAID_INJURED_MULTI_AT_TARGET		= 102,
   EFF_TARGET_TARGETS_INFRONT_CASTER					= 104,
   EFF_TARGET_CUSTOM_LOWEST_HP_PARTY_MEMBER				= 105,
   EFF_TARGET_CUSTOM_IN_FRONT_OF_CASTER_FRIENDLY		= 106,
   EFF_TARGET_LIST_LENGTH_MARKER						= 107,
} SpellEffectTarget;

enum SpellPreventionType
{
    SPELL_PREVENTION_TYPE_NONE      = 0,
    SPELL_PREVENTION_TYPE_SILENCE   = 1,
    SPELL_PREVENTION_TYPE_PACIFY    = 2,
    SPELL_PREVENTION_TYPE_UNK       = 3 // Only a few spells have this, but most of the should be interruptable.
};

typedef void(Spell::*pSpellTarget)(uint32 i, uint32 j);
extern pSpellTarget SpellTargetHandler[EFF_TARGET_LIST_LENGTH_MARKER];

inline bool HasTargetType(SpellEntry *sp,uint32 ttype)
{
	for(uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
		if( sp->eff[i].EffectImplicitTargetA==ttype || sp->eff[i].EffectImplicitTargetB==ttype )
			return true;
	return false;
}

inline bool HasEffectType(SpellEntry *sp,uint32 ttype)
{
	for(uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
		if( sp->eff[i].Effect == ttype )
			return true;
	return false;
}

inline bool HasAuraType(SpellEntry *sp,uint32 ttype)
{
	for(uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
		if( sp->eff[i].EffectApplyAuraName == ttype )
			return true;
	return false;
}

inline uint32 GetTargetCreatureType( SpellEntry *sp )
{
	SpellTargetRestrictionsEntry *str = dbcSpellTargetRestrictions.LookupEntryForced( sp->SpellTargetRestrictionsId );
	if( str )
		return str->TargetCreatureType;
	return 0;
}

inline uint32 GetMaxTargets( SpellEntry *sp )
{
	SpellTargetRestrictionsEntry *str = dbcSpellTargetRestrictions.LookupEntryForced( sp->SpellTargetRestrictionsId );
	if( str )
		return str->MaxAffectedTargets;
	return 0;
}

int GetAiTargetType(SpellEntry *sp);
bool IsTargetingStealthed(SpellEntry *sp);

ARCEMU_INLINE bool HasMechanic(SpellEntry * sp, uint32 MechanicsType)
{
	SpellCategoriesEntry *spc = dbcSpellCategories.LookupEntryForced( sp->SpellCategoriesId );
	if( spc && spc->Mechanic == MechanicsType )
		return true;
	for(uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
		if( sp->eff[i].EffectMechanic == MechanicsType )
			return true;
	return false;
}

/*
ARCEMU_INLINE TalentEntry * get_spell_talent_entry_for_talenttree(SpellEntry *sp,uint32 talent_tree)
{
	if( !sp )
		return NULL;
	//it is possible 1 spell is present in more then 1 talent tree. Try to find best match
	for(uint32 i=0;i<sp->talent_entry_assoc_counter;i++)
		if( sp->talent_entry[i]->TalentTree == talent_tree )
			return sp->talent_entry[i];
	return NULL;
}

ARCEMU_INLINE int get_spell_rank_in_talent( TalentEntry *tal, uint32 spell_id )
{
	if( !tal )
		return -1;
	for(int j = 0; j < 5; ++j)
		if( tal->RankID[j] == spell_id )
			return j;
	return -1;
}*/

// slow
struct SpellTargetMod
{
    SpellTargetMod(uint64 _TargetGuid, uint8 _TargetModType) : TargetGuid(_TargetGuid), TargetModType(_TargetModType)
    {

    }
    uint64 TargetGuid;
    uint8  TargetModType;
};


typedef std::vector<uint64> TargetsList;
typedef std::vector<SpellTargetMod> SpellTargetsList;

typedef void(Spell::*pSpellEffect)(uint32 i);

enum POWER_TYPES
{
	POWER_TYPE_HEALTH		= -2,
	POWER_TYPE_MANA			= 0,
	POWER_TYPE_RAGE			= 1,
	POWER_TYPE_FOCUS		= 2,
	POWER_TYPE_ENERGY		= 3,
	POWER_TYPE_HAPPINESS	= 4,
	POWER_TYPE_SUPPORTED_AS_UPDATEFIELD_COUNT = 5,
	POWER_TYPE_RUNES		= 5,	//this is used by auras combined with miscB value
	POWER_TYPE_RUNIC		= 6,
	POWER_TYPE_SOUL_SHARDS  = 7,  //check value
	POWER_TYPE_ECLIPSE      = 8,  //check value
	POWER_TYPE_HOLY         = 9,  //check value
	POWER_TYPE_HEALTH2      = 10, //seen it in power update packet
	POWER_TYPE_COUNT
};
// we have power type 15 and 31 :S

//let -1 mark undifined value
const int32 MaxPowerType[POWER_TYPE_COUNT]={-1,1000,100,100,1000,8,1000,3, 100 ,3};
const int32 MinPowerType[POWER_TYPE_COUNT]={-1,0   ,0  ,0  ,0   ,0,0   ,0,-100 ,0};

#define GO_FISHING_BOBBER 35591

#define SPELL_SPELL_CHANNEL_UPDATE_INTERVAL 1000
class DummySpellHandler;

enum SpellDidHitResult
{
	SPELL_DID_HIT_SUCCESS					= 0,
	SPELL_DID_HIT_MISS						= 1,
	SPELL_DID_HIT_RESIST					= 2,
	SPELL_DID_HIT_DODGE						= 3,
	SPELL_DID_HIT_DEFLECT					= 4,
	SPELL_DID_HIT_BLOCK						= 5,
	SPELL_DID_HIT_EVADE						= 6,
	SPELL_DID_HIT_IMMUNE					= 7,
};

enum SPellEffectRedirectTypes
{
	SPELL_EFFECT_REDIRECT_FLAG_EXECUTE				= 0,
	SPELL_EFFECT_REDIRECT_FLAG_REDIRECT_THIS_TARGET	= 1,
	SPELL_EFFECT_REDIRECT_FLAG_REDIRECT_ALL_TARGETS	= 2,
};

// Spell instance
class SERVER_DECL Spell
{
public:
    friend class DummySpellHandler;
    Spell( );
	void Init( Object* Caster, SpellEntry *info, bool triggered, Aura* aur );
	void Virtual_Constructor();		//when using object pool contructor is not good to be called again sometimes. Use this instead
    ~Spell();
	void Virtual_Destructor();		//this makes sure we do not leave events on objects that are supposed to be deleted
	int32 m_bufferPoolId;
#ifdef BUFFER_POOL_REMEMBER_HISTORY
	int	  m_bufferPoolPrevAllocLine;
	char  *m_bufferPoolPrevAllocFILE;
	int	  m_bufferPoolPrevDeAllocLine;
	char  *m_bufferPoolPrevDeAllocFILE;
#endif

    // Fills specified targets at the area of effect
    void FillSpecifiedTargetsInArea(float srcx,float srcy,float srcz,uint32 ind, uint32 specification);
    // Fills specified targets at the area of effect. We suppose we already inited this spell and know the details
    void FillSpecifiedTargetsInArea(uint32 i,float srcx,float srcy,float srcz, float range, uint32 specification);
    // Fills the targets at the area of effect
    void FillAllTargetsInArea(uint32 i, float srcx,float srcy,float srcz, float range);
    // Fills the targets at the area of effect. We suppose we already inited this spell and know the details
    void FillAllTargetsInArea(float srcx,float srcy,float srcz,uint32 ind);
    // Fills the targets at the area of effect. We suppose we already inited this spell and know the details
    void FillAllTargetsInArea(const LocationVector & location,uint32 ind);
    // Fills the targets at the area of effect. We suppose we already inited this spell and know the details
    void FillAllFriendlyInArea(uint32 i, float srcx,float srcy,float srcz, float range);
    //get single Enemy as target
    uint64 GetSinglePossibleEnemy(uint32 i, float prange=0);
    //get single Enemy as target
    uint64 GetSinglePossibleFriend(uint32 i, float prange=0);
    //generate possible target list for a spell. Use as last resort since it is not acurate
    void GenerateTargets(SpellCastTargets *store_buff);
    // Fills the target map of the spell packet
    void FillTargetMap(uint32);
    // See if we hit the target or can it resist (evade/immune/resist on spellgo) (0=success)
    uint8 DidHit(uint32 effindex,Unit* target);
    uint8 DidHitFriendly(uint32 effindex,Unit* target);
    // Prepares the spell thats going to cast to targets
    uint8 prepare(SpellCastTargets * targets);
	//amg do not cancel spell from the spell you are casting or you get a big fuckup
	ARCEMU_INLINE void safe_cancel( bool ObjectIsDestroyed = false );
    // Update spell state based on time difference
    void update(uint32 difftime);
    // Casts the spell
    void cast(bool);
    // Finishes the casted spell
    void finish();
    // Handle the Effects of the Spell
    void HandleEffects(uint64 guid,uint32 i);
    // Take Power from the caster based on spell power usage
    bool TakePower();
    // Has power?
    bool HasPower();
    // Trigger Spell function that triggers triggered spells
    void TriggerSpell();
    // Checks the caster is ready for cast
    uint8 CanCast(bool);
    // Removes reagents, ammo, and items/charges
    void RemoveItems();
    // Calculates the i'th effect value
    int32 CalculateEffect(uint32, Unit *target);
    // Handles Teleport function
    void HandleTeleport(uint32 id, Unit* Target);
    // Determines how much skill caster going to gain
    void DetermineSkillUp();
    // Increases cast time of the spell
    void AddTime(uint32 type);
    void AddCooldown();
    void AddStartCooldown();

    ARCEMU_INLINE uint32 getState() { return m_spellState; }
    ARCEMU_INLINE void SetUnitTarget(Unit *punit){unitTarget=punit;}

    // Send Packet functions
    void SendCastResult(uint8 result,int32 p_extra = 0);
    void SendSpellStart();
    void SendSpellGo();
	static void SendSpellFail(Object *Attacker, Object *Target, uint32 SpellID, uint8 SpellFailType );
//    void SendLogExecute(uint32 damage, uint64 & targetGuid);
    void SendInterrupted(uint8 result);
    void SendChannelUpdate(uint32 time);
    void SendChannelStart(uint32 duration);
    void SendResurrectRequest(Player* target);
//    void SendHealSpellOnPlayer(Object* caster, Object* target, uint32 dmg,bool critical);
	void SendTameFailure( uint8 failure );
    

    void HandleAddAura(uint64 guid);
    void writeSpellGoTargets( StackWorldPacket * data );
    void writeSpellMissedTargets( StackWorldPacket * data );

    uint32 pSpellId;
    SpellEntry *ProcedOnSpell; //some spells need to know the origins of the proc too
    SpellCastTargets m_targets;

    void CreateItem(uint32 itemId);

    // Effect Handlers
    void SpellEffectNULL(uint32 i);
    void SpellEffectInstantKill(uint32 i);
    void SpellEffectSchoolDMG(uint32 i);
    void SpellEffectDummy(uint32 i);
    void SpellEffectTeleportUnits(uint32 i);
    void SpellEffectApplyAura(uint32 i);
    void SpellEffectPowerDrain(uint32 i);
    void SpellEffectHealthLeech(uint32 i);
    void SpellEffectHeal(uint32 i);
	void SpellEffectBind(uint32 i);
    void SpellEffectQuestComplete(uint32 i);
    void SpellEffectWeapondamageNoschool(uint32 i);
    void SpellEffectResurrect(uint32 i);
    void SpellEffectAddExtraAttacks(uint32 i);
    void SpellEffectDodge(uint32 i);
    void SpellEffectBlock(uint32 i);
    void SpellEffectParry(uint32 i);
    void SpellEffectCreateItem(uint32 i);
    void SpellEffectPersistentAA(uint32 i);
    void SpellEffectSummon(uint32 i);
    void SpellEffectLeap(uint32 i);
    void SpellEffectJumpBehindTarget(uint32 i);
	void SpellEffectJumpBehindTargetHighArc(uint32 i);
    void SpellEffectEnergize(uint32 i);
    void SpellEffectWeaponDmgPerc(uint32 i);
    void SpellEffectTriggerMissile(uint32 i);
    void SpellEffectOpenLock(uint32 i);
    void SpellEffectApplyAA(uint32 i);
    void SpellEffectLearnSpell(uint32 i);
    void SpellEffectSpellDefense(uint32 i);
    void SpellEffectDispel(uint32 i);
	void SpellEffectLanguage(uint32 i);
    void SpellEffectSummonWild(uint32 i);
    void SpellEffectSummonGuardian(uint32 i);
    void SpellEffectSkillStep(uint32 i);
    void SpellEffectSummonObject(uint32 i);
    void SpellEffectEnchantItem(uint32 i);
    void SpellEffectEnchantItemTemporary(uint32 i);
    void SpellEffectTameCreature(uint32 i);
    void SpellEffectSummonPet(uint32 i);
    void SpellEffectWeapondamage(uint32 i);
    void SpellEffectPowerBurn(uint32 i);
    void SpellEffectThreat(uint32 i);
    void SpellEffectTriggerSpell(uint32 i);
    void SpellEffectHealthFunnel(uint32 i);
    void SpellEffectPowerFunnel(uint32 i);
    void SpellEffectHealMaxHealth(uint32 i);
    void SpellEffectInterruptCast(uint32 i);
    void SpellEffectDistract(uint32 i);
    void SpellEffectPickpocket(uint32 i);
    void SpellEffectAddFarsight(uint32 i);
    void SpellEffectSummonPossessed(uint32 i);
//    void SpellEffectCreateSummonTotem(uint32 i);
    void SpellEffectEquipGlyph(uint32 i);
    void SpellEffectHealMechanical(uint32 i);
    void SpellEffectSummonObjectWild(uint32 i);
    void SpellEffectScriptEffect(uint32 i);
    void SpellEffectSanctuary(uint32 i);
    void SpellEffectAddComboPoints(uint32 i);
	void SpellEffectCreateHouse(uint32 i);
    void SpellEffectDuel(uint32 i);
    void SpellEffectStuck(uint32 i);
    void SpellEffectSummonPlayer(uint32 i);
    void SpellEffectActivateObject(uint32 i);
    void SpellEffectSummonTotem(uint32 i);
    void SpellEffectProficiency(uint32 i);
    void SpellEffectSendEvent(uint32 i);
    void SpellEffectSkinning(uint32 i);
    void SpellEffectCharge(uint32 i);
    void SpellEffectSummonCritter(uint32 i);
    void SpellEffectKnockBack(uint32 i);
    void SpellEffectInebriate(uint32 i);
    void SpellEffectFeedPet(uint32 i);
    void SpellEffectDismissPet(uint32 i);
    void SpellEffectReputation(uint32 i);
    void SpellEffectSummonObjectSlot(uint32 i);
    void SpellEffectDispelMechanic(uint32 i);
    void SpellEffectSummonDeadPet(uint32 i);
    void SpellEffectDestroyAllTotems(uint32 i);
    void SpellEffectSummonDemon(uint32 i);
    void SpellEffectAttackMe(uint32 i);
    void SpellEffectSkill(uint32 i);
    void SpellEffectApplyPetAura(uint32 i);
    void SpellEffectDummyMelee(uint32 i);
	void SpellEffectFilming(uint32 i);
    void SpellEffectPlayerPull( uint32 i );
    void SpellEffectSpellSteal(uint32 i);
    void SpellEffectProspecting(uint32 i);
    void SpellEffectOpenLockItem(uint32 i);
    void SpellEffectSelfResurrect(uint32 i);
    void SpellEffectDisenchant(uint32 i);
    void SpellEffectWeapon(uint32 i);
    void SpellEffectDefense(uint32 i);
    void SpellEffectDualWield(uint32 i);
    void SpellEffectSkinPlayerCorpse(uint32 i);
    void SpellEffectResurrectNew(uint32 i);
    void SpellEffectTranformItem(uint32);
    void SpellEffectEnvironmentalDamage(uint32);
    void SpellEffectLearnPetSpell(uint32 i);
    void SpellEffectEnchantHeldItem(uint32 i);
    void SpellEffectAddHonor(uint32 i);
    void SpellEffectSpawn(uint32 i);
    void SpellEffectApplyAura128(uint32 i);
    void SpellEffectTriggerSpellWithValue(uint32 i);
	void SpellEffectCreatePet(uint32 i);
	void SpellEffectTeachTaxiPath(uint32 i);
    void SpellEffectRuneActivate(uint32 i);
    void SpellEffectSummonTarget(uint32 i);
    void SpellEffectMilling(uint32 i);
    void SpellEffectRenamePet(uint32 i);
	void SpellEffectPlayMusic(uint32 i);
	void SpellEffectForgetSpecialization(uint32 i);
	void SpellEffectKillCredit(uint32 i);
	void SpellEffectRedirectThreat(uint32 i);
	void SpellEffectHealMaxHealthPCT(uint32 i);
	void SpellEffectEnergizeMaxEnergyPct(uint32 i);
	void SpellEffectReduceThreatPercent(uint32 i);
	void SpellEffectWMODamage(uint32 i);
 	void SpellEffectWMORepair(uint32 i);

    // Spell Targets Handlers
    void SpellTargetNULL(uint32 i, uint32 j);
    void SpellTargetDefault(uint32 i, uint32 j);
    void SpellTargetSelf(uint32 i, uint32 j);
    void SpellTargetInvisibleAOE(uint32 i, uint32 j);
    void SpellTargetFriendly(uint32 i, uint32 j);
    void SpellTargetPet(uint32 i, uint32 j);
    void SpellTargetSingleTargetEnemy(uint32 i, uint32 j);
    void SpellTargetCustomAreaOfEffect(uint32 i, uint32 j);
    void SpellTargetAreaOfEffect(uint32 i, uint32 j);
    void SpellTargetLandUnderCaster(uint32 i, uint32 j); /// I don't think this is the correct name for this one
    void SpellTargetAllPartyMembersRangeNR(uint32 i, uint32 j);
    void SpellTargetSingleTargetFriend(uint32 i, uint32 j);
    void SpellTargetAoE(uint32 i, uint32 j); // something special
    void SpellTargetSingleGameobjectTarget(uint32 i, uint32 j);
    void SpellTargetInFrontOfCaster(uint32 i, uint32 j);
    void SpellTargetSingleFriend(uint32 i, uint32 j);
    void SpellTargetGameobject_itemTarget(uint32 i, uint32 j);
    void SpellTargetPetOwner(uint32 i, uint32 j);
    void SpellTargetEnemysAreaOfEffect(uint32 i, uint32 j);
    void SpellTargetTypeTAOE(uint32 i, uint32 j);
    void SpellTargetAllyBasedAreaEffect(uint32 i, uint32 j);
    void SpellTargetScriptedAllSummonsDeathPact(uint32 i, uint32 j);
    void SpellTargetScriptedEffects(uint32 i, uint32 j);
    void SpellTargetSummon(uint32 i, uint32 j);
    void SpellTargetNearbyPartyMembers(uint32 i, uint32 j);
    void SpellTargetSingleTargetPartyMember(uint32 i, uint32 j);
    void SpellTargetScriptedEffects2(uint32 i, uint32 j);
    void SpellTargetPartyMember(uint32 i, uint32 j);
    void SpellTargetDummyTarget(uint32 i, uint32 j);
    void SpellTargetFishing(uint32 i, uint32 j);
    void SpellTargetType40(uint32 i, uint32 j);
    void SpellTargetTotem(uint32 i, uint32 j);
    void SpellTargetChainTargeting(uint32 i, uint32 j);
    void SpellTargetSimpleTargetAdd(uint32 i, uint32 j);
	void SpellTargetAllRaid(uint32 i, uint32 j);
    void SpellTargetTargetAreaSelectedUnit(uint32 i, uint32 j);
    void SpellTargetInFrontOfCaster2(uint32 i, uint32 j);
    void SpellTargetTargetPartyMember(uint32 i, uint32 j);
    void SpellTargetRaidSameClass(uint32 i, uint32 j);
    void SpellTargetCritterPet(uint32 i, uint32 j);
	void SpellEffectSetTalentSpecsCount(uint32 i);
	void SpellEffectActivateTalentSpec(uint32 i);
	//these are custom
    void SpellTargetRaidInrangeAtTarget(uint32 i, uint32 j);
    void SpellTargetSinglePartyInjured(uint32 i, uint32 j);
    void SpellTargetMultiplePartyInjured(uint32 i, uint32 j);
    void SpellTargetMultipleRaidInjured(uint32 i, uint32 j);
    void SpellTargetInFrontOfCasterFriendly(uint32 i, uint32 j);
	uint64 static FindLowestHealthRaidMember(Player *Target, uint32 dist, float at_x=0.0f, float at_y=0.0f, TargetsList *NotInList = NULL);
	uint64 static FindLowestFriendly(Player *Target, uint32 dist, float at_x=0.0f, float at_y=0.0f, TargetsList *NotInList = NULL);

//    void Heal(int32 amount, bool ForceCrit = false,uint32 eff_index = 0);

//    GameObject*		g_caster;
    Unit*			u_caster;
    Item*			i_caster;
    Player*			p_caster;
    Object*			m_caster;

    // 15007 = resurecting sickness
	
	// This returns SPELL_ENTRY_Spell_Dmg_Type where 0 = SPELL_DMG_TYPE_NONE, 1 = SPELL_DMG_TYPE_MAGIC, 2 = SPELL_DMG_TYPE_MELEE, 3 = SPELL_DMG_TYPE_RANGED
	// It should NOT be used for weapon_damage_type which needs: 0 = MELEE, 1 = OFFHAND, 2 = RANGED
//	ARCEMU_INLINE uint32 GetType() { return ( GetProto()->GetSpellDMGType() == SPELL_DMG_TYPE_NONE ? SPELL_DMG_TYPE_MAGIC : GetProto()->GetSpellDMGType() ); }
/*	ARCEMU_INLINE uint32 GetType() 
	{ 
		if( GetProto()->AttributesExC & FLAGS4_PLAYER_RANGED_SPELLS )
			return SPELL_DMG_TYPE_RANGED;
		return ( GetProto()->SchoolMask != 0 ? SPELL_DMG_TYPE_MAGIC : SPELL_DMG_TYPE_MELEE ); 
	}*/
	ARCEMU_INLINE uint32 GetType() { return GetProto()->dmg_type; };

    std::vector<uint64> UniqueTargets;
    SpellTargetsList    ModeratedTargets;

    ARCEMU_INLINE Item* GetItemTarget() { return itemTarget; }
    ARCEMU_INLINE Unit* GetUnitTarget() { return unitTarget; }
    ARCEMU_INLINE Player* GetPlayerTarget() { return playerTarget; }
    ARCEMU_INLINE GameObject* GetGameObjectTarget() { return gameObjTarget; }

    int32 chaincast_jump_pct_mod;
    // -------------------------------------------

	ARCEMU_INLINE SpellEntry* GetProto() { return m_spellInfo; }

/*	ARCEMU_INLINE SpellEntry* GetProto() { return (m_spellInfo_override == NULL) ?  m_spellInfo : m_spellInfo_override; }
	void InitProtoOverride()
	{
		if (m_spellInfo_override != NULL)
			return;
		m_spellInfo_override = dbcSpell.CreateCopy(m_spellInfo);
	}*/
    uint32 GetDuration();
	float GetRadius(uint32 i);

    ARCEMU_INLINE static uint32 GetBaseThreat(uint32 dmg)
    {
        //there should be a formula to determine what spell cause threat and which don't
/*        switch(GetProto()->NameHash)
        {
            //hunter's mark
            case 4287212498:
                {
                    return 0;
                }break;
        }*/
        return dmg;
    }
    bool IsStealthSpell();
    bool IsInvisibilitySpell();
    bool IsAspect();
//    bool IsSeal();
	void CheckAndInterruptStealth();

    
    int32	damage;
	int32	eff_values[MAX_SPELL_EFFECT_COUNT];	//this is the value returned by calculate values are only valid for effect i-1
    Aura*	m_triggeredByAura;
	int32	forced_basepoints[MAX_SPELL_EFFECT_COUNT];	//some talent inherit base points from previous caster spells
	int32	forced_miscvalues[MAX_SPELL_EFFECT_COUNT];	//some proc spells use settings based on previous actions : resist last received spell type
//	int32	forced_heal_crit_mod[MAX_SPELL_EFFECT_COUNT];	//!! this is only implemented for heal as the value is not passed down to unit functions
	int32	forced_pct_mod[MAX_SPELL_EFFECT_COUNT];
	int32	static_dmg[MAX_SPELL_EFFECT_COUNT];			//the forced values represent full values and not extra value should be added to them
	int32	forced_pct_mod_cur;
	int32	forced_duration; //some proc spells can override default duration

    bool m_triggeredSpell;
    bool m_AreaAura;
    //uint32 TriggerSpellId;  // used to set next spell to use
    //uint64 TriggerSpellTarget; // used to set next spell target
    int8	m_requiresCP;
	bool deleted;				//this is a big hack, interrupted spells get deteled 2 times atm(only some)
    float m_castPositionX;
    float m_castPositionY;
    float m_castPositionZ;
   
    uint32	castedItemId;
	uint8	SpellCastQueueIndex;
	uint32	GlyphSlot;		//when we put glyph to be used

//    void SendCastSuccess(Object * target);
//    void SendCastSuccess(const uint64& guid);

    bool duelSpell;

    /// Spell state's
    /// Spell failed
    ARCEMU_INLINE bool GetSpellFailed(){return m_Spell_Failed;}
    ARCEMU_INLINE void SetSpellFailed(bool failed = true){m_Spell_Failed = failed;}

    SpellReflectState Reflect(Unit * refunit);
    ARCEMU_INLINE SpellReflectState IsReflected() {return m_IsReflected;}
    ARCEMU_INLINE void SetReflected(SpellReflectState reflected) {m_IsReflected = reflected;}
	void ForcePowerUpdateEnable(){ m_rune_avail_before=0x80;} //required for frikkin missing packet
    
//	Spell * m_reflectedParent;

	int32		power_cost;	//can be health, runes, mana....
    uint32      Dur;
    uint8       redirected_effect[MAX_SPELL_EFFECT_COUNT];
protected:
    // Cancels the current spell. Note, you should not cancel already in progress of cast spells.
	// This might leak memory, but at least does not crash due to NULLED pointers
    void cancel();

    /// Spell state's
//    bool    m_usesMana;
    bool				m_Spell_Failed;        //for 5sr
    SpellReflectState   m_IsReflected;
    bool				m_Delayed;
    
    
    // Spell possibility's
//    bool m_CanRelect;
    
    bool hadEffect;

    uint32  m_spellState;
    int32   m_castTime;
    int32   m_timer;

    // Current Targets to be used in effect handler
    Unit*       unitTarget;
    Item*       itemTarget;
    GameObject* gameObjTarget;
    Player*     playerTarget;
    Corpse*     corpseTarget;
	uint32		channel_delays;//since 303 channeled spells get delayed only 3 times max

    uint8       cancastresult;
    bool        bDurSet;
    float       Rad[MAX_SPELL_EFFECT_COUNT];
    bool        bRadSet[MAX_SPELL_EFFECT_COUNT];
	bool        m_cancelled;
//	bool		m_isCasting;
	uint8		m_rune_avail_before;
//	uint8		m_runes_to_update; //we need to store the values for these later :P
    //void _DamageRangeUpdate();

	ARCEMU_INLINE bool HasTarget(const uint64& guid, TargetsList* tmpMap)
	{
		for(TargetsList::iterator itr = tmpMap->begin(); itr != tmpMap->end(); ++itr)
			if((*itr)==guid)
				return true;

		for(SpellTargetsList::iterator itr = ModeratedTargets.begin(); itr != ModeratedTargets.end(); ++itr)
			if((*itr).TargetGuid==guid)
				return true;

		return false;
	}

private:
    
    void SafeAddMissedTarget(uint64 guid);
    void SafeAddModeratedTarget(uint64 guid, uint16 type);

    friend class DynamicObject;
    void DetermineSkillUp(uint32 skillid,uint32 steps,uint32 targetlevel);
    void DetermineSkillUp(uint32 skillid,uint32 steps);
	void ApplyClassScriptOverridesToEffect(int32 &value, int32 i, Player *caster, Unit *target);

public:
    bool SafeAddTarget(TargetsList* tgt,uint64 guid);
    TargetsList m_targetUnits[MAX_SPELL_EFFECT_COUNT];		//watch it though !
	SpellEntry* m_spellInfo;
//	SpellEntry* m_spellInfo_override;//used by spells that should have dynamic variables in spellentry.
    uint32      add_damage;
	float		m_missilePitch;
	float		m_missileTravelTime;
	uint8		m_missileFlags;
	float		m_missilespeed;
	uint8		m_missileunkcheck;
	uint32		m_missle_unkdoodah, m_missle_unkdoodah2;
};

SERVER_DECL SpellEntry * CreateDummySpell(uint32 id);
SERVER_DECL void DynamicCreateAssignSpellStackGroup(SpellEntry *sp, uint32 MyGroup, char *MyGroupStr, bool IsSet = true );

#define MAX_PVP_DURATION 8000
void GetPVPDuration(uint32 * Duration, Unit * Target, SpellEntry * spell);
void ApplyDiminishingReturnTimer(uint32 * Duration, Unit * Target, SpellEntry * spell);
void ApplyDiminishingReturnTimer(uint32 * Duration, Unit * Target, uint32 grp, bool DoNotSetNew = false, uint32 MaxPVPDur=MAX_PVP_DURATION );
uint32 GetDiminishingGroup( SpellEntry *sp, uint32 NameHash );

#define AURA_DURATION_INDEX_5_SECONDS 28
#define AURA_DURATION_INDEX_10_SECONDS 1
#define AURA_DURATION_INDEX_15_SECONDS 8

ARCEMU_INLINE bool IsEnemyAoeTargetting( uint32 TargetType )
{
	switch( TargetType )
    {
        case EFF_TARGET_INVISIBLE_OR_HIDDEN_ENEMIES_AT_LOCATION_RADIUS:
        case EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS:
        case EFF_TARGET_ALL_ENEMY_IN_AREA:
        case EFF_TARGET_ALL_ENEMY_IN_AREA_INSTANT:
        case EFF_TARGET_ALL_ENEMIES_AROUND_CASTER:
        case EFF_TARGET_IN_FRONT_OF_CASTER:
        case EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED:
        case EFF_TARGET_ALL_ENEMY_AT_ENEMY_IN_AREA_CHANNELED:
		case EFF_TARGET_ALL_SCRIPTED_OR_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME:
		case EFF_TARGET_CHAIN:
		case EFF_TARGET_MULTIPLE_SUMMON_LOCATION:
		case EFF_TARGET_MULTIPLE_SUMMON_PET_LOCATION:
		case EFF_TARGET_SUMMON_LOCATION:
		case EFF_TARGET_ENEMYS_IN_ARE_CHANNELED_WITH_EXCEPTIONS:
		case EFF_TARGET_TARGETS_INFRONT_CASTER:
            return true;
    }
    return false;
}

ARCEMU_INLINE bool IsSpellEnemyAoeTargetting( SpellEntry *sp )
{
	for( uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
	{
		if( IsEnemyAoeTargetting( sp->eff[i].EffectImplicitTargetA ) )
			return true;
		if( IsEnemyAoeTargetting( sp->eff[i].EffectImplicitTargetB ) )
			return true;
	}
	return false;
}

ARCEMU_INLINE bool IsFriendlyAoeTargetting( uint32 TargetType )
{
	switch( TargetType )
    {
        case EFF_TARGET_ALL_PARTY_AROUND_CASTER:
        case EFF_TARGET_ALL_FRIENDLY_IN_AREA:
        case EFF_TARGET_ALL_SCRIPTED_OR_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME:
        case EFF_TARGET_ALL_PARTY_IN_AREA:
        case EFF_TARGET_ALL_PARTY:
        case EFF_TARGET_MULTIPLE_SUMMON_LOCATION:
        case EFF_TARGET_MULTIPLE_SUMMON_PET_LOCATION:
        case EFF_TARGET_ALL_RAID:
		case EFF_TARGET_AREAEFFECT_PARTY_AND_CLASS:
		case EFF_TARGET_MULTIPLE_GUARDIAN_SUMMON_LOCATION:
		case EFF_TARGET_CUSTOM_RAID_INRANGE:
		case EFF_TARGET_CUSTOM_PARTY_INJURED_MULTI:
            return true;
    }
    return false;
}

ARCEMU_INLINE bool IsSpellFriendlyAoeTargetting( SpellEntry *sp )
{
	for( uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
	{
		if( IsFriendlyAoeTargetting( sp->eff[i].EffectImplicitTargetA ) )
			return true;
		if( IsFriendlyAoeTargetting( sp->eff[i].EffectImplicitTargetB ) )
			return true;
	}
	return false;
}

ARCEMU_INLINE bool IsDirectFriendlyTargetting( uint32 TargetType, uint32 Jumps )
{
	switch( TargetType )
    {
        case EFF_TARGET_SELF:
        case EFF_TARGET_PET:
        case EFF_TARGET_SINGLE_FRIEND:
        case EFF_TARGET_GAMEOBJECT:
        case EFF_TARGET_GAMEOBJECT_ITEM:
        case EFF_TARGET_PET_MASTER:
		case EFF_TARGET_MINION:
		case EFF_TARGET_SINGLE_PARTY:
		case EFF_TARGET_SCRIPTED_OR_SINGLE_TARGET:
		case EFF_TARGET_SELF_FISHING:
		case EFF_TARGET_SCRIPTED_GAMEOBJECT:
		case EFF_TARGET_TOTEM_EARTH:
		case EFF_TARGET_TOTEM_WATER:
		case EFF_TARGET_TOTEM_AIR:
		case EFF_TARGET_TOTEM_FIRE:
		case EFF_TARGET_PARTY_MEMBER:
		case EFF_TARGET_TARGET_FOR_VISUAL_EFFECT:
		case EFF_TARGET_SCRIPTED_TARGET2:
            return true;
		case EFF_TARGET_CHAIN:
			if( Jumps <= 1 )
				return true;
    }
    return false;
}

ARCEMU_INLINE bool IsDirectEnemyTargetting( uint32 TargetType, uint32 Jumps )
{
	switch( TargetType )
    {
        case EFF_TARGET_SINGLE_ENEMY:
        case EFF_TARGET_DUEL:
		case EFF_TARGET_CURRENT_SELECTION:
		case EFF_TARGET_SELECTED_ENEMY_CHANNELED:
		case EFF_TARGET_SELECTED_ENEMY_DEADLY_POISON:
            return true;
		case EFF_TARGET_CHAIN:
			if( Jumps <= 1 )
				return true;
    }
    return false;
}

ARCEMU_INLINE bool IsSpellDirectTargetting( SpellEntry *sp )
{
	for( uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
	{
		if( IsDirectFriendlyTargetting( sp->eff[i].EffectImplicitTargetA, sp->eff[i].EffectChainTarget ) || IsDirectEnemyTargetting( sp->eff[i].EffectImplicitTargetA, sp->eff[i].EffectChainTarget ) )
			return true;
		if( IsDirectFriendlyTargetting( sp->eff[i].EffectImplicitTargetB, sp->eff[i].EffectChainTarget ) || IsDirectEnemyTargetting( sp->eff[i].EffectImplicitTargetB, sp->eff[i].EffectChainTarget ) )
			return true;
	}
	return false;
}

ARCEMU_INLINE bool IsSpellDirectFirendlyTargetting( SpellEntry *sp )
{
	for( uint32 i=0;i<MAX_SPELL_EFFECT_COUNT;i++)
	{
		if( IsDirectFriendlyTargetting( sp->eff[i].EffectImplicitTargetA, sp->eff[i].EffectChainTarget ) )
			return true;
		if( IsDirectFriendlyTargetting( sp->eff[i].EffectImplicitTargetB, sp->eff[i].EffectChainTarget ) )
			return true;
	}
	return false;
}

//!!!need to finish making this 
ARCEMU_INLINE bool IsSpellBenefic(SpellEntry * sp)
{
	return ((sp->c_is_flags & SPELL_FLAG_IS_DAMAGING) == 0);
}
ARCEMU_INLINE bool IsSpellHarmfull(SpellEntry * sp)
{
	return IsSpellBenefic(sp) == false;
}

//void SendHealSpellOnPlayer(Object* caster, Object* target, uint32 dmg,bool critical,SpellEntry *sp);

ARCEMU_INLINE bool IsVisibleAura(SpellEntry* m_spellProto)
{ 
	if(!m_spellProto) 
		return false; 		
	return (((m_spellProto->Attributes & ATTRIBUTES_PASSIVE) == false || (m_spellProto->AttributesEx & ATTRIBUTESEX_VISIBLE)) && ( m_spellProto->SpellIconID != 1 || m_spellProto->activeIconID != 0 ));
}

ARCEMU_INLINE float Distance2DSq(const float & x, const float & y, const float & X, const float & Y)
{
	float delta_x = X - x;
	float delta_y = Y - y;
	return (delta_x*delta_x + delta_y*delta_y);
}

ARCEMU_INLINE float Distance2DSq(Object * o1,Object * o2)
{
	float delta_x = o1->GetPositionX() - o2->GetPositionX();
	float delta_y = o1->GetPositionY() - o2->GetPositionY();
	return (delta_x*delta_x + delta_y*delta_y);
}

ARCEMU_INLINE float Distance3DSq(float x1, float y1, float z1, float x2, float y2, float z2)
{
	float delta_x = x1 - x2;
	float delta_y = y1 - y2;
	float delta_z = z1 - z2;
	return (delta_x*delta_x + delta_y*delta_y + delta_z*delta_z);
}

ARCEMU_INLINE float DistanceSq(Object * o1,Object * o2)
{
	float delta_x = o1->GetPositionX() - o2->GetPositionX();
	float delta_y = o1->GetPositionY() - o2->GetPositionY();
	float delta_z = o1->GetPositionZ() - o2->GetPositionZ();
	return (delta_x*delta_x + delta_y*delta_y + delta_z*delta_z);
}

ARCEMU_INLINE bool IsInrange(float x1,float y1, float z1, Object * o,float square_r)
{
	float t;
	float r;
	t=x1-o->GetPositionX();
	r=t*t;
	t=y1-o->GetPositionY();
	r+=t*t;
	t=z1-o->GetPositionZ();
	r+=t*t;
	return ( r<=square_r);
}

ARCEMU_INLINE bool IsInrange(float x1,float y1, Object * o,float square_r)
{
	float t;
	float r;
	t=x1-o->GetPositionX();
	r=t*t;
	t=y1-o->GetPositionY();
	r+=t*t;
	return ( r<=square_r);
}

int32 GetSpellAmplitude( SpellEntry *sp, Unit *Unitc, int32 i, uint32 ItemCast );

void SetItemSpellProcInterval( SpellEntry *sp, int32 LoopCounter = 0, int32 *OwnerInterval = 0, bool IsTrinket = false );
void SetItemSpellSPCoeff( SpellEntry *sp, int32 LoopCounter = 0 );

SERVER_DECL void GetSpellLinkByProto(uint32 SpellID, char *buffer );

#define GLYPH_WARLOCK_CONFLAGRATE		273
#define GLYPH_WARLOCK_FEAR				277
#define GLYPH_WARLOCK_SOUL_SWAP			285
#define GLYPH_WARLOCK_OF_FELHUNTER		279
#define GLYPH_WARLOCK_SOUL_LINK			761
#define GLYPH_PRIEST_PAIN_SUPRESSION	713
#define GLYPH_PRIEST_POWERWORDBARRIER	262
#define GLYPH_PRIEST_SHADOW_WORD_DEATH	268
#define GLYPH_PRIEST_PSYCHIC_SCREAM		265
#define GLYPH_PRIEST_OF_DESPERATION		713
#define GLYPH_PRIEST_SHADOWFORM			961
#define GLYPH_WARRIOR_DEVASTATE			493
#define GLYPH_WARRIOR_EXECUTE			494
#define GLYPH_WARRIOR_INTIMIDATING_SHOUT	765
#define GLYPH_WARRIOR_DEATH_WISH		932
#define GLYPH_MAGE_EVOCATION			315
#define GLYPH_MAGE_POLYMORPH			329
#define GLYPH_MAGE_PENGUIN				450
#define GLYPH_MAGE_MONKEY				447
#define GLYPH_MAGE_FROST_NOVA			318
#define GLYPH_MAGE_FROSTFIRE			591
#define GLYPH_MAGE_FROSTFIRE_BOLT		651
#define GLYPH_DEATHKNIGHT_RUNE_TAP		556
#define GLYPH_DEATHKNIGHT_UNHOLY_BLIGHT	770
#define GLYPH_DEATHKNIGHT_DEATH_STRIKE	558
#define GLYPH_DEATHKNIGHT_RAISE_DEAD	527
#define GLYPH_DRUID_SWIFTMEND			168
#define GLYPH_DRUID_TREANT				937
#define GLYPH_SHAMAN_LIGHTNING_SHIELD	225
#define GLYPH_SHAMAN_HEALING_STREAM_TOTEM	222
#define GLYPH_SHAMAN_SPECTRAL_WOLF		471
#define GLYPH_SHAMAN_FERAL_SPIRIT		736
#define GLYPH_PALADIN_EXORCISM			193
#define GLYPH_PALADIN_HOLY_WRATH		559
#define GLYPH_PALADIN_LONG_WORD			930
#define GLYPH_ROGUE_KICK				926
#define GLYPH_ROGUE_GOUGE				403

void SendInterruptLog( Object *Caster, uint32 CastedSpellID, Object *Target, uint32 InterruptedSpell);
void SendPowerStealLog( Player *p_caster, uint32 CastedSpellID, Object *Target, uint32 PowerAmt, uint32 PowerType,float Mult);
void SendGainExtraAttacksLog( Player *p_caster, uint32 CastedSpellID, Object *Target, uint32 Count);
void SendDurabilityDMGLog( Player *p_caster, uint32 CastedSpellID, Object *Target, uint32 ItemID, uint32 Slot);
void SendOpenLockLog( Player *p_caster, uint32 CastedSpellID, Object *Target);
void SendCreateItemLog( Player *p_caster, uint32 CastedSpellID, uint32 ItemID);
void SendDestroyItemLog( Player *p_caster, uint32 CastedSpellID, uint32 ItemID);
void SendSummonLog( Player *p_caster, uint32 CastedSpellID, Object *Target, uint32 Count);
void SendUnSummonLog( Player *p_caster, uint32 CastedSpellID, Object *Target, uint32 Count);
void SendResurrectLog( Player *p_caster, uint32 CastedSpellID, Object *Target);

#endif
